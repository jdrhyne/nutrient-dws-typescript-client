/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
    "/build": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Process documents and download the result
         * @description This endpoint lets you use [Build instructions](#tag/Build-API) to process a document. This allows you to
         *     assemble a PDF from multiple parts, such as an existing document in a supported content type, a blank page,
         *     or an HTML page. You can apply one or more actions, such as watermarking, rotating pages, or importing
         *     annotations. Once the entire PDF is generated from its parts, you can also apply additional actions,
         *     such as optical character recognition (OCR), to the assembled PDF itself.
         *
         */
        post: operations["build-document"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/analyze_build": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Analyze a build request
         * @description Performs analysis of the Build API request without actually executing it.
         *
         *     Use this endpoint to calculate how many credits a Build API request would consume. The request is free of charge.
         *
         *     Note: Make sure to provide the correct `content_type` parameter for each of your file parts to get accurate results.
         *     Otherwise, the endpoint might not correctly identify conversion features such as Office or image conversion.
         *
         */
        post: operations["analyze_build"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sign": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Digitally sign a PDF file
         * @description Use this endpoint to digitally sign a PDF file.
         *
         */
        post: operations["sign-file"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/tokens": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Generate a new API token
         * @description Use this endpoint to generate a new API token. All request body parameters are optional.
         *
         */
        post: operations["generate-token"];
        /**
         * Revoke an API token
         * @description Use this endpoint to revoke an API token.
         *
         */
        delete: operations["revoke-token"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/account/info": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get account information
         * @description Use this endpoint to get information about your account, such as the number of credits you have left.
         *
         */
        get: operations["get-account-info"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/ai/redact": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Redact sensitive information from a document
         * @description Redacts sensitive information from a document based on the provided criteria.
         *
         */
        post: operations["ai-redact"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
}
export type webhooks = Record<string, never>;
export interface components {
    schemas: {
        /** @example {
         *       "cost": 3.5,
         *       "required_features": {
         *         "annotation_api": [
         *           {
         *             "unit_cost": 0.5,
         *             "unit_type": "per_use",
         *             "units": 3,
         *             "cost": 1.5,
         *             "usage": [
         *               "$.parts[0].actions[0]",
         *               "$.parts[1].actions[1]",
         *               "$.actions[0]"
         *             ]
         *           }
         *         ],
         *         "document_editor_api": [
         *           {
         *             "unit_cost": 1,
         *             "unit_type": "per_use",
         *             "units": 1,
         *             "cost": 1,
         *             "usage": [
         *               "$.parts[1].merge"
         *             ]
         *           }
         *         ],
         *         "ocr_api": [
         *           {
         *             "unit_cost": 2,
         *             "unit_type": "per_use",
         *             "units": 1,
         *             "cost": 2,
         *             "usage": [
         *               "$.parts[1].actions[0]"
         *             ]
         *           }
         *         ],
         *         "pdf_to_pdfua_api": [
         *           {
         *             "unit_cost": 5,
         *             "unit_type": "per_output_page",
         *             "units": 3,
         *             "cost": 15,
         *             "usage": [
         *               "$.output"
         *             ]
         *           }
         *         ]
         *       }
         *     } */
        AnalyzeBuildResponse: {
            /**
             * @description Total cost in credits charged after executing the request.
             *
             * @example 1.5
             */
            cost?: number;
            /** @description Usage statistics for all features required to execute the request.
             *      */
            required_features?: {
                [key: string]: {
                    /**
                     * @description Credits cost per use of the feature.
                     * @example 0.5
                     */
                    unit_cost?: number;
                    /**
                     * @description Type of the unit used for billing. Possible values:
                     *
                     *     * `per_use` - `units` field represent number of uses of this particular feature in a Build request.
                     *     * `per_output_page` - `units` field represents number of pages of the Build request output.
                     *
                     * @example per_use
                     * @enum {string}
                     */
                    unit_type?: "per_use" | "per_output_page";
                    /**
                     * @description Number of feature uses in the request.
                     * @example 3
                     */
                    units?: number;
                    /**
                     * @description Cost for feature uses in the request.
                     * @example 1.5
                     */
                    cost?: number;
                    /** @description JSON paths to the parts of instructions where the feature was used.
                     *      */
                    usage?: string[];
                };
            };
        };
        /**
         * Instant JSON
         * @description Instant JSON is a format for bringing annotations and bookmarks into a modern format while keeping all important properties to make the Instant JSON spec work with PDF.
         *
         */
        InstantJson: {
            /** @enum {string} */
            format: "https://pspdfkit.com/instant-json/v1";
            annotations?: (components["schemas"]["Annotation"] | components["schemas"]["Annotation.v1"])[];
            attachments?: components["schemas"]["Attachments"];
            formFields?: components["schemas"]["FormField"][];
            formFieldValues?: components["schemas"]["FormFieldValue"][];
            bookmarks?: components["schemas"]["Bookmark"][];
            comments?: components["schemas"]["CommentContent"][];
            /** @description An array of PDF object IDs that should be skipped during the import process. Whenever an object ID is marked as skipped, it'll no longer be loaded from the original PDF. Instead, it could be defined inside the annotations array with the same pdfObjectId. If this is the case, the PDF viewer will display the new annotation, which signals an update to the original one. If an object ID is marked as skipped but the annotations array doesn't contain an annotation with the same pdfObjectId, it'll be interpreted as a deleted annotation. An annotation inside the annotations array without the pdfObjectId property is interpreted as a newly created annotation. */
            skippedPdfObjectIds?: number[];
            /** @description PDF document identifiers, base64 encoded. This is used to track version of PDF document this JSON has been exported from. */
            pdfId?: {
                /**
                 * @description Permanent document identifier based on the contents of the file at the time it was originally created. Does not change when the file is saved incrementally.
                 * @example 9C3nLxNzQBuBBzv96LbdMg==
                 */
                permanent?: string;
                /**
                 * @description Document identifier based on the file's contents at the time it was last updated.
                 * @example Oi+XccZpDHChV7I=
                 */
                changing?: string;
            };
        };
        CreateAuthTokenParameters: {
            /**
             * @description List of operations that can be performed with the generated token.
             *     Defaults to all operations.
             *
             * @example [
             *       "digital_signatures_api"
             *     ]
             */
            allowedOperations?: ("annotations_api" | "compression_api" | "data_extraction_api" | "digital_signatures_api" | "document_editor_api" | "html_conversion_api" | "image_conversion_api" | "image_rendering_api" | "email_conversion_api" | "linearization_api" | "ocr_api" | "office_conversion_api" | "pdfa_api" | "pdf_to_office_conversion_api" | "redaction_api")[];
            /** @description List of origins that can use the generated token.
             *     By default, allows all origins.
             *      */
            allowedOrigins?: string[];
            /**
             * @description The expiration time of the token in seconds.
             *
             * @default 3600
             */
            expirationTime: number;
        };
        CreateAuthTokenResponse: {
            /**
             * @description The ID of the generated token.
             * @example a1b2c3d4-e5f6-g7h8-i9j0-k1l2m3n4o5p6
             */
            id?: string;
            /**
             * @description The generated API token.
             * @example eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjoxMjM0NTY3ODkwLCJpYXQiOjE1MTYyMzkwMjJ9.4TJ4J7
             */
            accessToken?: string;
        };
        RedactData: {
            /** @description An array of documents to analyze for redaction. */
            documents: {
                file?: string | {
                    /** @description A URL pointing to a document to redact. */
                    url: string;
                };
                /** @description Optional. Limits the analysis to specific pages. */
                pages?: number[] | {
                    /** @description Starting page index (0-based). */
                    start: number;
                    /** @description Ending page index. A positive number denotes an absolute page index,
                     *     negative number denotes a relative page index from the end of the document.
                     *      */
                    end: number;
                };
            }[];
            /** @description The redaction criteria such as "Redact all PII", or "All personal names and addresses", etc. */
            criteria: string;
            /**
             * @description When set to "stage", marks locations for redaction; when set to "apply", marks and removes content permanently. Optional, defaults to "stage".
             * @default stage
             * @enum {string}
             */
            redaction_state: "stage" | "apply";
            /** @description Optional configuration for the redaction process. */
            options?: {
                /** @description Configuration for confidence-based filtering of redactions. */
                confidence?: {
                    /** @description Optionally filter terms which are scored with a confidence level less than the threshold. Scores range from 1-10. */
                    threshold: number;
                };
            };
        };
        FileHandle: {
            /**
             * @description Specifies the URL from a file can be downloaded
             * @example https://remote-file-storage/input-file
             */
            url: string;
            /** @description Optional parameter to verify a downloaded file using provided SHA256 hash.
             *     It is expected to be base16 encoded using lowercase.
             *      */
            sha256?: string;
        } | string;
        /** @description Defines the range of pages in a document. The indexing starts from 0. It is possible
         *     to use negative numbers to refer to pages from the last page. For example, `-1` refers to the last page.
         *      */
        PageRange: {
            /** @default 0 */
            start?: number;
            /** @default -1 */
            end?: number;
        };
        /** @description Defines the layout of the generated pages.
         *      */
        PageLayout: {
            /**
             * @description The orientation of generated pages.
             *
             * @default portrait
             * @enum {string}
             */
            orientation?: "portrait" | "landscape";
            size?: ("A0" | "A1" | "A2" | "A3" | "A4" | "A5" | "A6" | "A7" | "A8" | "Letter" | "Legal") | {
                /**
                 * @description The width of pages in mm.
                 *
                 * @example 210
                 */
                width?: number;
                /**
                 * @description The height of pages in mm.
                 *
                 * @example 297
                 */
                height?: number;
            };
            /** @description The margins of generated pages. All dimensions are in mm.
             *      */
            margin?: {
                /** @default 0 */
                left: number;
                /** @default 0 */
                top: number;
                /** @default 0 */
                right: number;
                /** @default 0 */
                bottom: number;
            };
        };
        ApplyInstantJsonAction: {
            /**
             * @description Apply the Instant JSON to the document to import annotations or forms to a document.
             *
             * @enum {string}
             */
            type: "applyInstantJson";
            file: components["schemas"]["FileHandle"];
        };
        ApplyXfdfAction: {
            /**
             * @description Apply the XFDF to the document to import annotations to a document.
             *
             * @enum {string}
             */
            type: "applyXfdf";
            file: components["schemas"]["FileHandle"];
            /**
             * @description If `true`, ignores page rotation when applying XFDF data.
             * @default false
             */
            ignorePageRotation?: boolean;
            /**
             * @description If `true`, plain text annotations will be converted to rich text annotations.
             *     If `false`, all text annotations will be plain text annotations.
             *
             * @default true
             */
            richTextEnabled?: boolean;
        };
        FlattenAction: {
            /**
             * @description Flatten the annotations in the document.
             *
             * @enum {string}
             */
            type: "flatten";
            /** @description Annotation IDs to flatten. These can be annotation IDs or `pdfObjectId`s.
             *     If not specified, all annotations will be flattened.
             *      */
            annotationIds?: (string | number)[];
        };
        /**
         * @description Language to be used for the OCR text extraction. You can find the list of supported languages in our [guides](https://www.nutrient.io/guides/document-engine/ocr/language-support/).
         *     In addition to the languages outlined in the guides, we support the 3 letter ISO 639-2 code for some other languages.
         *
         * @example english
         * @enum {string}
         */
        OcrLanguage: "afrikaans" | "albanian" | "arabic" | "armenian" | "azerbaijani" | "basque" | "belarusian" | "bengali" | "bosnian" | "bulgarian" | "catalan" | "chinese" | "croatian" | "czech" | "danish" | "dutch" | "english" | "finnish" | "french" | "german" | "indonesian" | "italian" | "malay" | "norwegian" | "polish" | "portuguese" | "serbian" | "slovak" | "slovenian" | "spanish" | "swedish" | "turkish" | "welsh" | "afr" | "amh" | "ara" | "asm" | "aze" | "bel" | "ben" | "bod" | "bos" | "bre" | "bul" | "cat" | "ceb" | "ces" | "chr" | "cos" | "cym" | "dan" | "deu" | "div" | "dzo" | "ell" | "eng" | "enm" | "epo" | "equ" | "est" | "eus" | "fao" | "fas" | "fil" | "fin" | "fra" | "frk" | "frm" | "fry" | "gla" | "gle" | "glg" | "grc" | "guj" | "hat" | "heb" | "hin" | "hrv" | "hun" | "hye" | "iku" | "ind" | "isl" | "ita" | "jav" | "jpn" | "kan" | "kat" | "kaz" | "khm" | "kir" | "kmr" | "kor" | "kur" | "lao" | "lat" | "lav" | "lit" | "ltz" | "mal" | "mar" | "mkd" | "mlt" | "mon" | "mri" | "msa" | "mya" | "nep" | "nld" | "nor" | "oci" | "ori" | "osd" | "pan" | "pol" | "por" | "pus" | "que" | "ron" | "rus" | "san" | "sin" | "slk" | "slv" | "snd" | "sp1" | "spa" | "sqi" | "srp" | "sun" | "swa" | "swe" | "syr" | "tam" | "tat" | "tel" | "tgk" | "tgl" | "tha" | "tir" | "ton" | "tur" | "uig" | "ukr" | "urd" | "uzb" | "vie" | "yid" | "yor";
        OcrAction: {
            /**
             * @description Perform optical character recognition (OCR) in the document.
             *
             * @enum {string}
             */
            type: "ocr";
            language: components["schemas"]["OcrLanguage"] | components["schemas"]["OcrLanguage"][];
        };
        RotateAction: {
            /**
             * @description Rotate all pages by the angle specified.
             *
             * @enum {string}
             */
            type: "rotate";
            /**
             * @description The angle by which the pages should be rotated, clockwise.
             *
             * @enum {number}
             */
            rotateBy: 90 | 180 | 270;
        };
        WatermarkDimension: {
            /**
             * @description Dimension value
             * @example 100
             */
            value: number;
            /**
             * @description Dimension unit
             * @enum {string}
             */
            unit: "pt" | "%";
        };
        BaseWatermarkAction: {
            /**
             * @description Watermark all pages with text watermark.
             *
             * @enum {string}
             */
            type: "watermark";
            width:  components["schemas"]["WatermarkDimension"];
            height: components["schemas"]["WatermarkDimension"];
            top?: components["schemas"]["WatermarkDimension"];
            right?: components["schemas"]["WatermarkDimension"];
            bottom?: components["schemas"]["WatermarkDimension"];
            left?: components["schemas"]["WatermarkDimension"];
            /**
             * @description Rotation of the watermark in counterclockwise degrees.
             *
             * @default 0
             */
            rotation: number;
            /** @description Watermark opacity. 0 is fully transparent, 1 is fully opaque. */
            opacity?: number;
        };
        TextWatermarkAction: components["schemas"]["BaseWatermarkAction"] & {
            /** @description Text used for watermarking
             *      */
            text: string;
            /**
             * @description The font to render the text. Fonts are client specific, so you should only use fonts you know are present in the browser where they should be displayed. If a font isn't found, PSPDFKit will automatically fall back to a sans-serif font.
             * @example Helvetica
             */
            fontFamily?: string;
            /**
             * @description Size of the text in points.
             * @example 10
             */
            fontSize?: number;
            /**
             * @description A foreground color of the text.
             * @example #ffffff
             */
            fontColor?: string;
            /** @description Text style. Can be only italic, only bold, italic and bold, or none of these. */
            fontStyle?: ("bold" | "italic")[];
        };
        ImageWatermarkAction: components["schemas"]["BaseWatermarkAction"] & {
            image: components["schemas"]["FileHandle"];
        };
        WatermarkAction: components["schemas"]["TextWatermarkAction"] | components["schemas"]["ImageWatermarkAction"];
        /**
         * @description Page index of the annotation. 0 is the first page.
         * @example 0
         */
        PageIndex: number;
        /**
         * @description Bounding box of the annotation within the page in a form [left, top, width, height].
         * @example [
         *       255.10077620466092,
         *       656.7566095695641,
         *       145.91672653256705,
         *       18.390804597701162
         *     ]
         */
        AnnotationBbox: number[];
        /** BaseAction */
        BaseAction: {
            /** @description Sub-action to execute after the action has been executed. */
            subAction?: Record<string, never>;
        };
        /** GoToAction */
        GoToAction: components["schemas"]["BaseAction"] & {
            /** @enum {string} */
            type: "goTo";
            /** @description Page index to navigate to. 0 is the first page. */
            pageIndex: number;
        };
        /** GoToRemoteAction */
        GoToRemoteAction: components["schemas"]["BaseAction"] & {
            /** @enum {string} */
            type: "goToRemote";
            /**
             * @description The relative path of the file to open.
             * @example /other_document.pdf
             */
            relativePath: string;
            namedDestination?: string;
        };
        /** GoToEmbeddedAction */
        GoToEmbeddedAction: components["schemas"]["BaseAction"] & {
            /** @enum {string} */
            type: "goToEmbedded";
            /**
             * @description The relative path to the embedded file.
             * @example /other_document.pdf
             */
            relativePath: string;
            /** @description Whether to open the file in a new window. */
            newWindow?: boolean;
            /** @enum {string} */
            targetType?: "parent" | "child";
        };
        /** LaunchAction */
        LaunchAction: components["schemas"]["BaseAction"] & {
            /** @enum {string} */
            type: "launch";
            /**
             * @description The file path to launch.
             * @example /other_document.pdf
             */
            filePath: string;
        };
        /** URIAction */
        URIAction: components["schemas"]["BaseAction"] & {
            /** @enum {string} */
            type: "uri";
            /** @example https://www.nutrient.io */
            uri: string;
        };
        /** AnnotationReference */
        AnnotationReference: {
            fieldName?: string;
            pdfObjectId?: number;
        };
        /** HideAction */
        HideAction: components["schemas"]["BaseAction"] & {
            /** @enum {string} */
            type: "hide";
            hide: boolean;
            annotationReferences: components["schemas"]["AnnotationReference"][];
        };
        /** JavaScriptAction */
        JavaScriptAction: components["schemas"]["BaseAction"] & {
            /** @enum {string} */
            type: "javascript";
            script: string;
        };
        /** SubmitFormAction */
        SubmitFormAction: components["schemas"]["BaseAction"] & {
            /** @enum {string} */
            type: "submitForm";
            uri: string;
            flags: ("includeExclude" | "includeNoValueFields" | "exportFormat" | "getMethod" | "submitCoordinated" | "xfdf" | "includeAppendSaves" | "includeAnnotations" | "submitPDF" | "canonicalFormat" | "excludeNonUserAnnotations" | "excludeFKey" | "embedForm")[];
            fields?: components["schemas"]["AnnotationReference"][];
        };
        /** ResetFormAction */
        ResetFormAction: components["schemas"]["BaseAction"] & {
            /** @enum {string} */
            type: "resetForm";
            /** @enum {string} */
            flags?: "includeExclude";
            fields?: components["schemas"]["AnnotationReference"][];
        };
        /** NamedAction */
        NamedAction: components["schemas"]["BaseAction"] & {
            /** @enum {string} */
            type: "named";
            /** @enum {string} */
            action: "nextPage" | "prevPage" | "firstPage" | "lastPage" | "goBack" | "goForward" | "goToPage" | "find" | "print" | "outline" | "search" | "brightness" | "zoomIn" | "zoomOut" | "saveAs" | "info";
        };
        /**
         * @description Represents a PDF action.
         *
         *     There are many different action types. You can learn more about their semantics
         *     [here](https://www.nutrient.io/guides/ios/annotations/pdf-actions/).
         *
         *     All actions have a `type` property. Depending on the type, the action object
         *     includes additional properties.
         *
         * @example {
         *       "type": "goTo",
         *       "pageIndex": 0
         *     }
         */
        Action: components["schemas"]["GoToAction"] | components["schemas"]["GoToRemoteAction"] | components["schemas"]["GoToEmbeddedAction"] | components["schemas"]["LaunchAction"] | components["schemas"]["URIAction"] | components["schemas"]["HideAction"] | components["schemas"]["JavaScriptAction"] | components["schemas"]["SubmitFormAction"] | components["schemas"]["ResetFormAction"] | components["schemas"]["NamedAction"];
        /** @description Annotation opacity. 0 is fully transparent, 1 is fully opaque. */
        AnnotationOpacity: number;
        /** @description The PDF object ID of the annotation from the source PDF. */
        PdfObjectId: number;
        /**
         * @description Object of arbitrary properties attached to the annotations. PSPDFKit won't modify this data when processing annotations.
         *
         * @example {
         *       "foo": "bar"
         *     }
         */
        AnnotationCustomData: {
            [key: string]: unknown;
        } | null;
        /** BaseAnnotation */
        BaseAnnotation: {
            /**
             * @description The specification version that the record is compliant to.
             * @enum {integer}
             */
            v: 2;
            /** @description The type of the annotation. */
            type: string;
            pageIndex: components["schemas"]["PageIndex"];
            bbox: components["schemas"]["AnnotationBbox"];
            action?: components["schemas"]["Action"];
            opacity?: components["schemas"]["AnnotationOpacity"];
            pdfObjectId?: components["schemas"]["PdfObjectId"];
            /**
             * @description The unique Instant JSON identifier of the annotation.
             * @example 01DNEDPQQ22W49KDXRFPG4EPEQ
             */
            id?: string;
            /** @description Array of annotation flags.
             *
             *     | Flag | Description |
             *     | ---- | ----------- |
             *     | noPrint | Don't print. |
             *     | noZoom | Don't zoom with page. |
             *     | noRotate | Don't rotate. |
             *     | noView | Don't display, can be still printed. |
             *     | hidden | Don't display, don't print, disable any interaction with user. |
             *     | invisible | Ignore annotation AP stream. |
             *     | readOnly | Don't allow the annotation to be deleted or its properties modified. |
             *     | locked | Same as `readOnly` but allows changing annotation contents. |
             *     | lockedContents | Don't allow the contents of the annotation to be modified. |
             *      */
            flags?: ("noPrint" | "noZoom" | "noRotate" | "noView" | "hidden" | "invisible" | "readOnly" | "locked" | "toggleNoView" | "lockedContents")[];
            /**
             * Format: date-time
             * @description The date of the annotation creation. ISO 8601 with full date, time, and time zone information
             * @example 2019-09-16T15:05:03.712909Z
             */
            createdAt?: string;
            /**
             * Format: date-time
             * @description The date of the last annotation update. ISO 8601 with full date, time, and time zone information
             * @example 2019-09-16T15:05:03.712909Z
             */
            updatedAt?: string;
            /** @description The name of the annotation used to identify the annotation. */
            name?: string;
            /** @description The name of the creator of the annotation. */
            creatorName?: string;
            customData?: components["schemas"]["AnnotationCustomData"];
        };
        /**
         * Rect
         * @description Rectangle in a form [left, top, width, height] in PDF points (pt).
         * @example [
         *       100,
         *       200,
         *       300,
         *       400
         *     ]
         */
        Rect: number[];
        /**
         * Rotation
         * @description Counterclockwise annotation rotation in degrees.
         * @enum {integer}
         */
        AnnotationRotation: 0 | 90 | 180 | 270;
        /**
         * Note
         * @description Text of an annotation note.
         * @example This is a note.
         */
        AnnotationNote: string;
        /** RedactionAnnotation */
        RedactionAnnotation: components["schemas"]["BaseAnnotation"] & {
            /** @enum {string} */
            type: "pspdfkit/markup/redaction";
            /** @description Bounding boxes of the marked text. */
            rects?: components["schemas"]["Rect"][];
            /**
             * @description Outline color is the border color of a redaction annotation when it hasn't yet been applied to the document
             * @example #ffffff
             */
            outlineColor?: string;
            /** @description Fill color is the background color that a redaction will have when applied to the document. */
            fillColor?: string;
            /**
             * @description The text that will be printed on top of an applied redaction annotation.
             * @example CONFIDENTIAL
             */
            overlayText?: string;
            /** @description Specifies whether or not the overlay text will be repeated multiple times to fill the boundaries of the redaction annotation. */
            repeatOverlayText?: boolean;
            /**
             * @description Color of the overlay text (if any).
             * @example #ffffff
             */
            color?: string;
            rotation?: components["schemas"]["AnnotationRotation"];
            note?: components["schemas"]["AnnotationNote"];
        };
        /**
         * @description - `credit-card-number` — matches a number with 13 to 19 digits that begins with 1—6.
         *     Spaces and `-` are allowed anywhere in the number.
         *     - `date` — matches date formats such as `mm/dd/yyyy`, `mm/dd/yy`, `dd/mm/yyyy`, and `dd/mm/yy`.
         *     It rejects any days greater than 31 or months greater than 12 and accepts a leading 0 in front of a single-digit day or month.
         *     The delimiter can be `-`, `.`, or `/`.
         *     - `email-address` — matches an email address. Expects the format of `*@*.*` with at least two levels of the domain name.
         *     - `international-phone-number` — matches international phone numbers.
         *     The number can have 7 to 15 digits with spaces or `-` occurring anywhere within the number, and it must have prefix of `+` or `00`.
         *     - `ipv4` — matches an IPv4 address with an optional mask at the end.
         *     - `ipv6` — matches a full and compressed IPv6 address as defined in [RFC 2373](http://www.faqs.org/rfcs/rfc2373.html).
         *     - `mac-address` — matches a MAC address with either `-` or `:` as a delimiter.
         *     - `north-american-phone-number` — matches North American-style phone numbers.
         *     NANPA standardization is used with international support.
         *     - `social-security-number` — matches a social security number.
         *     Expects the format of `XXX-XX-XXXX` or `XXXXXXXXX`, with X denoting digits.
         *     - `time` — matches time formats such as `00:00:00`, `00:00`, and `00:00 PM`. 12- and 24-hour formats are allowed.
         *     Seconds and AM/PM denotation are both optional.
         *     - `url` — matches a URL with a prefix of `http` or `https`, with an optional subdomain.
         *     - `us-zip-code` — matches a USA-style zip code. The format expected is `XXXXX`, `XXXXX-XXXX` or `XXXXX/XXXX`.
         *     - `vin` — matches US and ISO Standard 3779 Vehicle Identification Number.
         *     The format expects 17 characters, with the last 5 characters being numeric. `I`, `i`, `O`, `o` ,`Q`, `q`, and `_` characters are not allowed.
         *
         * @example email-address
         * @enum {string}
         */
        SearchPreset: "credit-card-number" | "date" | "email-address" | "international-phone-number" | "ipv4" | "ipv6" | "mac-address" | "north-american-phone-number" | "social-security-number" | "time" | "url" | "us-zip-code" | "vin";
        CreateRedactionsStrategyOptionsPreset: {
            preset: components["schemas"]["SearchPreset"];
            /**
             * @description Determines if redaction annotations are created on top of annotations whose
             *     content match the provided preset.
             *
             * @default true
             */
            includeAnnotations?: boolean;
            /**
             * @description The index of the page from where you want to start the search.
             *
             * @default 0
             */
            start?: number;
            /**
             * @description Starting from start, the number of pages to search. Default is to the end of
             *     the document.
             *
             * @default null
             */
            limit?: number;
        };
        CreateRedactionsStrategyOptionsRegex: {
            /**
             * @description Regex search term used for searching for text to redact.
             *
             * @example @pspdfkit\\.com
             */
            regex: string;
            /**
             * @description Determines if redaction annotations are created on top of annotations whose
             *     content match the provided preset.
             *
             * @default true
             */
            includeAnnotations?: boolean;
            /**
             * @description Determines if the search will be case sensitive.
             *
             * @default true
             */
            caseSensitive?: boolean;
            /**
             * @description The index of the page from where you want to start the search.
             *
             * @default 0
             */
            start?: number;
            /**
             * @description Starting from start, the number of pages to search. Default is to the end of
             *     the document.
             *
             * @default null
             */
            limit?: number;
        };
        CreateRedactionsStrategyOptionsText: {
            /**
             * @description Search term used for searching for text to redact.
             *
             * @example @nutrient.io
             */
            text: string;
            /**
             * @description Determines if redaction annotations are created on top of annotations whose
             *     content match the provided preset.
             *
             * @default true
             */
            includeAnnotations?: boolean;
            /**
             * @description Determines if the search will be case sensitive.
             *
             * @default false
             */
            caseSensitive?: boolean;
            /**
             * @description The index of the page from where you want to start the search.
             *
             * @default 0
             */
            start?: number;
            /**
             * @description Starting from start, the number of pages to search. Default is to the end of
             *     the document.
             *
             * @default null
             */
            limit?: number;
        };
        CreateRedactionsAction: {
            /**
             * @description Creates redactions according to the given strategy. Once redactions are created, they need to be applied using the `applyRedactions` action.
             *     You can configure some visual aspects of the redaction annotation, including its background color, overlay text, and so on, by passing an optional `content` object.
             *
             * @enum {string}
             */
            type: "createRedactions";
            content?: components["schemas"]["RedactionAnnotation"];
        } & ({
            /** @enum {string} */
            strategy: "preset";
            strategyOptions: components["schemas"]["CreateRedactionsStrategyOptionsPreset"];
        } | {
            /** @enum {string} */
            strategy: "regex";
            strategyOptions: components["schemas"]["CreateRedactionsStrategyOptionsRegex"];
        } | {
            /** @enum {string} */
            strategy: "text";
            strategyOptions: components["schemas"]["CreateRedactionsStrategyOptionsText"];
        });
        ApplyRedactionsAction: {
            /**
             * @description Applies the redactions created by an earlier `createRedactions` action.
             *
             * @enum {string}
             */
            type: "applyRedactions";
        };
        BuildAction: components["schemas"]["ApplyInstantJsonAction"] | components["schemas"]["ApplyXfdfAction"] | components["schemas"]["FlattenAction"] | components["schemas"]["OcrAction"] | components["schemas"]["RotateAction"] | components["schemas"]["WatermarkAction"] | components["schemas"]["CreateRedactionsAction"] | components["schemas"]["ApplyRedactionsAction"];
        /** @example {
         *       "file": "pdf-file-from-multipart"
         *     } */
        FilePart: {
            file: components["schemas"]["FileHandle"];
            /** @description The password for the input file */
            password?: string;
            pages?: components["schemas"]["PageRange"];
            layout?: Record<string, never> & components["schemas"]["PageLayout"];
            /**
             * @description The content type of the file. Used to determine the file type when the file content type is not available and can't be inferred.
             *
             * @example application/pdf
             */
            content_type?: string;
            actions?: components["schemas"]["BuildAction"][];
        };
        HTMLPart: {
            html: components["schemas"]["FileHandle"];
            /** @description List of asset names imported in the HTML. References the name passed in the multipart request.
             *      */
            assets?: string[];
            layout?: components["schemas"]["PageLayout"];
            actions?: components["schemas"]["BuildAction"][];
        };
        NewPagePart: {
            /** @enum {string} */
            page: "new";
            /**
             * @description Number of pages to be added.
             * @default 1
             */
            pageCount?: number;
            layout?: components["schemas"]["PageLayout"];
            actions?: components["schemas"]["BuildAction"][];
        };
        /**
         * Document ID
         * @description The ID of the document.
         * @example 7KPZW8XFGM4F1C92KWBK1B748M
         */
        DocumentId: string;
        /** @description This allows to reference a document stored on Document Engine.
         *     It is also possible to refer to currently scoped file by using special ID:
         *       ```
         *       {"document": {"id": "#self"}}
         *       ```
         *      */
        DocumentPart: {
            document: {
                // eslint-disable-next-line @typescript-eslint/no-redundant-type-constituents
                id: components["schemas"]["DocumentId"] | "#self";
                /**
                 * @description The name of the layer to be used.
                 *
                 * @example my-existing-layer
                 */
                layer?: string;
            };
            /** @description The password for the input file */
            password?: string;
            pages?: components["schemas"]["PageRange"];
            actions?: components["schemas"]["BuildAction"][];
        };
        Part: components["schemas"]["FilePart"] | components["schemas"]["HTMLPart"] | components["schemas"]["NewPagePart"] | components["schemas"]["DocumentPart"];
        /**
         * @description The document title.
         * @example Nutrient Document Engine API Specification
         */
        Title: string | null;
        Metadata: {
            title?: components["schemas"]["Title"];
            /**
             * @description The document author.
             * @example Document Author
             */
            author?: string;
        };
        Label: {
            /** @description Array of page numbers (0-based indexing) */
            pages: number[];
            /**
             * @description The label to apply to specified pages.
             * @example Page I-III
             */
            label: string;
        };
        /** @enum {string} */
        PDFUserPermission: "printing" | "modification" | "extract" | "annotations_and_forms" | "fill_forms" | "extract_accessibility" | "assemble" | "print_high_quality";
        OptimizePdf: {
            /** @default false */
            grayscaleText?: boolean;
            /** @default false */
            grayscaleGraphics?: boolean;
            /** @default false */
            grayscaleImages?: boolean;
            /** @default false */
            grayscaleFormFields?: boolean;
            /** @default false */
            grayscaleAnnotations?: boolean;
            /** @default false */
            disableImages?: boolean;
            /** @default false */
            mrcCompression?: boolean;
            /** @default 2 */
            imageOptimizationQuality?: number;
            /**
             * @description If set to `true`, the resulting PDF file will be linearized.
             *     This means that the document will be optimized in a special way that allows it to be loaded faster over the network.
             *     You need the `Linearization` feature to be enabled in your Nutrient Document Engine license in order to use this option.
             *
             * @default false
             */
            linearize?: boolean;
        };
        /** @description Object representing PDF output.
         *      */
        BasePDFOutput: {
            metadata?: components["schemas"]["Metadata"];
            labels?: components["schemas"]["Label"][];
            /** @description Defines the password which allows to open a file with defined
             *     permissions
             *      */
            user_password?: string;
            /** @description Defines the password which allows to manage the permissions for the file
             *      */
            owner_password?: string;
            /** @description Defines the permissions which are granted when a file is opened with user password
             *      */
            user_permissions?: components["schemas"]["PDFUserPermission"][];
            optimize?: components["schemas"]["OptimizePdf"];
        };
        PDFOutput: components["schemas"]["BasePDFOutput"] & {
            /** @enum {string} */
            type?: "pdf";
        };
        PDFAOutput: components["schemas"]["BasePDFOutput"] & {
            /** @enum {string} */
            type: "pdfa";
            /**
             * @description Defines the conformance level of the output file.
             *     The default value is `pdfa-1b`.
             *
             *     These are the only supported conformance levels at this time.
             *
             * @enum {string}
             */
            conformance?: "pdfa-1a" | "pdfa-1b" | "pdfa-2a" | "pdfa-2u" | "pdfa-2b" | "pdfa-3a" | "pdfa-3u";
            /**
             * @description When set to true, produces vector based graphic elements where applicable. For example: fonts and paths.
             *
             * @default true
             */
            vectorization?: boolean;
            /**
             * @description When set to true, produces raster based graphic elements where applicable. For example: images.
             *
             * @default true
             */
            rasterization?: boolean;
        };
        PDFUAOutput: components["schemas"]["BasePDFOutput"] & {
            /** @enum {string} */
            type: "pdfua";
        };
        /**
         * ImageOutput
         * @description Render the document as an image.
         */
        ImageOutput: {
            /** @enum {string} */
            type: "image";
            /**
             * @description The format of the rendered image.
             *
             * @default png
             * @enum {string}
             */
            format?: "png" | "jpeg" | "jpg" | "webp";
            pages?: components["schemas"]["PageRange"];
            /** @description The width of the rendered image in pixels. You must specify at least one of either width, height or dpi
             *      */
            width?: number;
            /** @description The height of the rendered image in pixels. You must specify at least one of either width, height or dpi
             *      */
            height?: number;
            /** @description The resolution of the rendered image in dots per inch. You must specify at least one of either width, height or dpi
             *      */
            dpi?: number;
        };
        /**
         * JSONContentOutput
         * @description JSON with document contents. Returned for `json-content` output type.
         *
         */
        JSONContentOutput: {
            /** @enum {string} */
            type: "json-content";
            /**
             * @description When set to true, extracts document text. Text is extracted via OCR process.
             *
             * @default true
             */
            plainText?: boolean;
            /**
             * @description When set to true, extracts structured document text. This includes text words, characters, lines and paragraphs.
             *
             * @default false
             */
            structuredText?: boolean;
            /**
             * @description When set to true, extracts key-value pairs detected within the document contents. Example of detected values are phone numbers, email addresses, currencies, numbers, dates, etc.
             *
             * @default false
             */
            keyValuePairs?: boolean;
            /**
             * @description When set to true, extracts tabular data from the document.
             *
             * @default true
             */
            tables?: boolean;
            language?: components["schemas"]["OcrLanguage"] | components["schemas"]["OcrLanguage"][];
        };
        /** OfficeOutput */
        OfficeOutput: {
            /**
             * @description The output office file type.
             *
             * @enum {string}
             */
            type: "docx" | "xlsx" | "pptx";
        };
        /** HTMLOutput */
        HTMLOutput: {
            /** @enum {string} */
            type: "html";
            /**
             * @description The layout type to use for conversion to HTML:
             *
             *     * `page` layout keeps the original structure of the document, segmented by page.
             *     * `reflow` layout converts the document into a continuous flow of text, without page breaks.
             *
             * @enum {string}
             */
            layout?: "page" | "reflow";
        };
        /** MarkdownOutput */
        MarkdownOutput: {
            /** @enum {string} */
            type: "markdown";
        };
        BuildOutput: components["schemas"]["PDFOutput"] | components["schemas"]["PDFAOutput"] | components["schemas"]["PDFUAOutput"] | components["schemas"]["ImageOutput"] | components["schemas"]["JSONContentOutput"] | components["schemas"]["OfficeOutput"] | components["schemas"]["HTMLOutput"] | components["schemas"]["MarkdownOutput"];
        BuildInstructions: {
            /** @description Parts of the document to be built.
             *
             *     Multiple types of parts are supported:
             *     * `FilePart` that represents a binary input file that can be either a part name in the `multipart/form-data` request or an URL of a remote file.
             *     * `HTMLPart` that represents an HTML input file along with it's assets.
             *     * `NewPagePart` that represents a document with empty pages.
             *     * `DocumentPart` that represents a document (with optional layer) managed by Nutrient Document Engine. Only applicable if used in a Document Engine context.
             *      */
            parts: components["schemas"]["Part"][];
            /** @description Actions to be performed on the document after it is built.
             *      */
            actions?: components["schemas"]["BuildAction"][];
            output?: components["schemas"]["BuildOutput"];
        };
        /**
         * @description Page text extracted via OCR process. This property is present only when `plainText` is set to `true`.
         *
         * @example Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Aenean commodo ligula eget dolor. Aenean massa.
         */
        PlainText: string;
        /** @description Represents a rectangular region on the page. Both coordinates and directions are in PDF points with the origin at the top-left corner of the page. */
        JsonContentsBbox: {
            /** @example 0 */
            left: number;
            /** @example 0 */
            top: number;
            /** @example 100 */
            width: number;
            /** @example 100 */
            height: number;
        };
        Character: {
            bbox: components["schemas"]["JsonContentsBbox"];
            /** @example T */
            value: string;
        };
        Line: {
            bbox: components["schemas"]["JsonContentsBbox"];
            /**
             * @description The index of the first word of the line from the `characters`  array.
             * @example 0
             */
            firstWordIndex: number;
            /**
             * @description Specifies if the line is written from right to left.
             * @example false
             */
            isRTL: boolean;
            /**
             * @description Specifies if the line is vertically oriented.
             * @example false
             */
            isVertical: boolean;
            /**
             * @description The number of words in the line.
             * @example 5
             */
            wordCount: number;
        };
        Paragraph: {
            bbox: components["schemas"]["JsonContentsBbox"];
            /**
             * @description The index of the first line of the paragraph from the `lines` array.
             * @example 0
             */
            firstLineIndex: number;
            /**
             * @description The number of lines in the paragraph.
             * @example 3
             */
            lineCount: number;
        };
        Word: {
            bbox: components["schemas"]["JsonContentsBbox"];
            /**
             * @description The number of characters in the word.
             * @example 4
             */
            characterCount: number;
            /**
             * @description The index of the first character of the word from the `characters` array.
             * @example 0
             */
            firstCharacterIndex: number;
            /**
             * @description Specifies if the word has been identified from the OCR dictionary.
             * @example true
             */
            isFromDictionary: boolean;
            /**
             * @description The actual word text.
             * @example word
             */
            value: string;
        };
        StructuredText: {
            /** @description A list of characters detected within the page. */
            characters?: components["schemas"]["Character"][];
            /** @description A list of lines detected within the page. */
            lines?: components["schemas"]["Line"][];
            /** @description A list of paragraphs detected within the page. */
            paragraphs?: components["schemas"]["Paragraph"][];
            /** @description A list of words detected within the page. */
            words?: components["schemas"]["Word"][];
        };
        /**
         * @description Specifies the confidence score of pair, in the range [0 - 100].
         * @example 95.4
         */
        Confidence: number;
        /** @description The key of the detected key-value pair. */
        KVPKey: {
            bbox: components["schemas"]["JsonContentsBbox"];
            /**
             * @description The detected key text. `#` is the value does not have a key.
             *
             * @example #
             */
            content: string;
        };
        /** @description The value of the detected key-value pair. */
        KVPValue: {
            bbox: components["schemas"]["JsonContentsBbox"];
            /**
             * @description The detected value text.
             * @example €
             */
            content: string;
            /**
             * @description The value type. One of the following: `Unknown`, `PhoneNumber`, `EmailAddress`, `Currency`, `Number`, `DateTime`, `String`, `PostCode`, `URL`, `Percentage`, `Symbol`, `VatIDValue`, `TimePeriod`, `IBAN`, `BIC`, `CreditCard`, `UID`, `PostalAddress`, `VIN`, `SSN`
             *
             * @example Currency
             */
            dataType: string;
        };
        KeyValuePair: {
            confidence: components["schemas"]["Confidence"];
            key: components["schemas"]["KVPKey"];
            value: components["schemas"]["KVPValue"];
        };
        TableCell: {
            bbox: components["schemas"]["JsonContentsBbox"];
            /**
             * @description An index of a row the cell belongs to (0-based).
             * @example 0
             */
            rowIndex: number;
            /**
             * @description An index of a column the cell belongs to (0-based).
             * @example 0
             */
            columnIndex: number;
            /**
             * @description Specifies if the cell has been identified as a part of the table header.
             * @example true
             */
            isHeader: boolean;
            /**
             * @description The content of the cell.
             * @example Invoice number
             */
            text: string;
        };
        TableColumn: {
            bbox: components["schemas"]["JsonContentsBbox"];
        };
        TableLine: {
            bbox: components["schemas"]["JsonContentsBbox"];
            /**
             * @description Specifies if the line is oriented vertically.
             * @example false
             */
            isVertical?: boolean;
            /** @description The thickness of the line, in PDF points. */
            thickness?: number;
        };
        TableRow: {
            bbox: components["schemas"]["JsonContentsBbox"];
        };
        Table: {
            confidence: components["schemas"]["Confidence"];
            bbox: components["schemas"]["JsonContentsBbox"];
            /** @description A list of table cells. */
            cells: components["schemas"]["TableCell"][];
            /** @description A list of table columns. */
            columns: components["schemas"]["TableColumn"][];
            /** @description A list of physical lines in the table. */
            lines: components["schemas"]["TableLine"][];
            /** @description A list of table rows. */
            rows: components["schemas"]["TableRow"][];
        };
        PageJsonContents: {
            /**
             * @description 0-based index of the page in the document.
             * @example 0
             */
            pageIndex: number;
            plainText?: components["schemas"]["PlainText"];
            structuredText?: components["schemas"]["StructuredText"];
            /** @description A list of detected key-value pairs on the page. */
            keyValuePairs?: components["schemas"]["KeyValuePair"][];
            /** @description A list of detected tables on the page. */
            tables?: components["schemas"]["Table"][];
        };
        BuildResponseJsonContents: {
            pages?: components["schemas"]["PageJsonContents"][];
        };
        HostedErrorResponse: {
            /** @example The request is malformed */
            details?: string;
            /** @enum {integer} */
            status?: 400 | 402 | 408 | 413 | 422 | 500;
            /** @example xy123zzdafaf */
            requestId?: string;
            /** @description List of failing paths. */
            failingPaths?: {
                /** @example $.property[0] */
                path?: string;
                /** @example Missing required property */
                details?: string;
            }[];
        };
        /**
         * CreateDigitalSignature
         * @example {
         *       "signatureType": "cades",
         *       "flatten": false,
         *       "appearance": {
         *         "mode": "signatureOnly",
         *         "contentType": "image/png",
         *         "showWatermark": true,
         *         "showSignDate": true
         *       },
         *       "position": {
         *         "pageIndex": 0
         *       },
         *       "cadesLevel": "b-lt"
         *     }
         */
        CreateDigitalSignature: {
            /**
             * @description The signature type to create.
             *     Note: While this field is required if sending signature parameters,
             *     the entire `data` object itself is optional in the multipart request.
             *
             * @default cms
             * @enum {string}
             */
            signatureType: "cms" | "cades";
            /**
             * @description Controls whether to flatten the document before signing it.
             *     This is useful when you want the document's appearance to remain stable before signing and to ensure there's no indication that the document can be edited after signing.
             *
             *     Note that the resulting document's records (annotations and form fields) will be deleted.
             *
             * @default false
             */
            flatten: boolean;
            /**
             * @description Name of the signature form field to sign. Use this when signing an existing signature form field.
             *     If a signature field with this name does not exist in the document, it will be created at the position specified with `position`.
             *
             *     If a signature field with the specified name exists and `position` is also set, the request will result in an error.
             *
             *     Note: Either `formFieldName` or `position` must be provided if creating a visible signature.
             *
             * @example signatureI-field
             */
            formFieldName?: string;
            /** @description The appearance settings for the visible signature. Omit if you want an invisible signature to be created.
             *      */
            appearance?: {
                /**
                 * @description Specifies what will be rendered in the signature appearance: graphics, description, or both.
                 *     Visit the [Configure Digital Signature Appearance guide](https://www.nutrient.io/guides/web/signatures/digital-signatures/signature-lifecycle/configure-digital-signature-appearance/) for a detailed description of the signature modes.
                 *
                 * @default signatureAndDescription
                 * @example signatureOnly
                 * @enum {string}
                 */
                mode: "signatureOnly" | "signatureAndDescription" | "descriptionOnly";
                /**
                 * @description The content type of the watermark image when provided in the `image` parameter of the multipart request.
                 *     Supported types are `application/pdf`, `image/png`, and `image/jpeg`.
                 *
                 * @example image/png
                 */
                contentType?: string;
                /**
                 * @description Controls whether to include the watermark in the signature appearance.
                 *     When `true` and a watermark image is provided via the `watermark` parameter, it will be included.
                 *     When `true` and no watermark image is provided, the Nutrient logo will be used as the default watermark.
                 *
                 * @default true
                 */
                showWatermark: boolean;
                /**
                 * @description Controls whether to show the signing date and time in the signature appearance.
                 *     When `true`, the date and time will be shown in ISO 8601 format.
                 *     Example: 2023-06-15 13:57:31
                 *
                 * @default true
                 */
                showSignDate: boolean;
                /**
                 * @description Controls whether to include the timezone in the signing date.
                 *     Only applies when `showSignDate` is `true`.
                 *
                 * @default false
                 */
                showDateTimezone: boolean;
            };
            /** @description Position of the visible signature form field. Omit if you want an invisible signature or if you specified the `formFieldName` option.
             *      */
            position?: {
                /** @description The index of the page where the signature appearance will be rendered.
                 *      */
                pageIndex: number;
                /**
                 * @description An array of 4 numbers (points) representing the bounding box where the signature appearance will be rendered on the specified `pageIndex`.
                 *
                 *     [left, top, width, height]
                 *
                 *     The unit is PDF points (1 PDF point equals 1⁄72 of an inch).
                 *     The first two numbers describe the [left,top] coordinates of the top left corner of the bounding box,
                 *     while the second two numbers describe the width and height of the bounding box.
                 *
                 * @example [
                 *       0,
                 *       0,
                 *       100,
                 *       100
                 *     ]
                 */
                rect: number[];
            };
            /**
             * @description The CAdES level to use when creating the signature. The default value is `CAdES B-LT`.
             *     This parameter is ignored when the `signatureType` is `cms`.
             *
             *     This is more like a hint of what level to use, and you should be aware that the API can return `b-b` even when you ask for `b-lt`. This can happen when the timestamp authority server is down, etc.
             *
             *     If this API is invoked with the [Document Engine](https://www.nutrient.io/sdk/document-engine), you can override the default with the following environment variable: [`DIGITAL_SIGNATURE_CADES_LEVEL`](https://www.nutrient.io/guides/document-engine/configuration/options/).
             *
             *     For Long-Term Validation (LTV) of the signature - when this API is invoked with the [Document Engine](https://www.nutrient.io/sdk/document-engine) - you need to ensure that the signing certificate chain links to a trusted anchor Certificate Authority (CA) at the time of signing.
             *
             *     To add the root CA and necessary intermediate CAs to your Document Engine instance, follow the instructions in [our guide on Providing Trusted Root Certificates](https://www.nutrient.io/guides/document-engine/signatures/signature-lifecycle/validation/#providing-trusted-root-certificates).
             *
             * @default b-lt
             * @enum {string}
             */
            cadesLevel: "b-lt" | "b-t" | "b-b";
        };
        /**
         * BlendMode
         * @enum {string}
         */
        BlendMode: "normal" | "multiply" | "screen" | "overlay" | "darken" | "lighten" | "colorDodge" | "colorBurn" | "hardLight" | "softLight" | "difference" | "exclusion";
        /**
         * isCommentThreadRoot
         * @description Indicates whether the annotation is the root of a comment thread.
         *
         */
        IsCommentThreadRoot: boolean;
        /** MarkupAnnotation */
        MarkupAnnotation: components["schemas"]["BaseAnnotation"] & {
            /** @enum {unknown} */
            type: "pspdfkit/markup/highlight" | "pspdfkit/markup/squiggly" | "pspdfkit/markup/strikeout" | "pspdfkit/markup/underline";
            /** @description Bounding boxes of the marked text. */
            rects: components["schemas"]["Rect"][];
            blendMode?: components["schemas"]["BlendMode"];
            /**
             * @description Foreground color
             * @example #fcee7c
             */
            color: string;
            note?: components["schemas"]["AnnotationNote"];
            isCommentThreadRoot?: components["schemas"]["IsCommentThreadRoot"];
        };
        /** @description The text contents. */
        AnnotationText: {
            /**
             * @description The format of the annotation's contents. Can be either `xhtml` or `plain`.
             *     If `xhtml` is used, the text will be rendered as XHTML.
             *     If `plain` is used, the text will be rendered as plain text.
             *
             *     Supported XHTML tags include `span`, `p`, `html`, `body`, `b`, `i`, and `a`.
             *     Hyperlinks are also supported in the `a` tags using the `href` attribute.
             *     Styles are supported by using inline styles with the `style` attribute.
             *     Supported CSS properties include `background-color`, `font-weight`, `font-style`, `text-decoration`, `color`
             *
             * @enum {string}
             */
            format?: "xhtml" | "plain";
            /**
             * @description Actual text content of the annotation. This is the text that will be displayed in the annotation.
             *
             * @example Annotation with <b>xhtml</b> contents.
             */
            value?: string;
        };
        /**
         * FontSizeInt
         * @description Size of the text in PDF points.
         * @example 10
         */
        FontSizeInt: number;
        /** @description Text style. Can be only italic, only bold, italic and bold, or none of these. */
        FontStyle: ("bold" | "italic")[];
        /**
         * FontColor
         * @description A foreground color of the text.
         * @example #ffffff
         */
        FontColor: string;
        /**
         * Font
         * @description The font to render the text. Fonts are client specific, so you should only use fonts you know are present in the browser where they should be displayed. If a font isn't found, PSPDFKit will automatically fall back to a sans-serif font.
         * @example Helvetica
         */
        Font: string;
        /**
         * HorizontalAlign
         * @description Alignment of the text along the horizontal axis.
         * @enum {string}
         */
        HorizontalAlign: "left" | "center" | "right";
        /**
         * VerticalAlign
         * @description Alignment of the text along the vertical axis.
         *
         *     Note that vertical align is a custom PSPDFKit extension that might not be honored by 3rd party readers.
         *
         * @enum {string}
         */
        VerticalAlign: "top" | "center" | "bottom";
        /**
         * Point
         * @description Point coordinates in a form [x, y] in PDF points (pt).
         * @example [
         *       100,
         *       200
         *     ]
         */
        Point: number[];
        /**
         * LineCap
         * @enum {string}
         */
        LineCap: "square" | "circle" | "diamond" | "openArrow" | "closedArrow" | "butt" | "reverseOpenArrow" | "reverseClosedArrow" | "slash";
        /**
         * BorderStyle
         * @enum {string}
         */
        BorderStyle: "solid" | "dashed" | "beveled" | "inset" | "underline";
        /** CloudyBorderIntensity */
        CloudyBorderIntensity: number;
        /**
         * CloudyBorderInset
         * @description Inset used for drawing cloudy borders in a form [left, top, right, bottom].
         */
        CloudyBorderInset: number[];
        /** TextAnnotation */
        TextAnnotation: components["schemas"]["BaseAnnotation"] & {
            /** @enum {string} */
            type: "pspdfkit/text";
            text: components["schemas"]["AnnotationText"];
            fontSize: components["schemas"]["FontSizeInt"];
            fontStyle?: components["schemas"]["FontStyle"];
            fontColor?: components["schemas"]["FontColor"];
            font?: components["schemas"]["Font"];
            /**
             * BackgroundColor
             * @description A background color that will fill the bounding box.
             * @example #000000
             */
            backgroundColor?: string;
            horizontalAlign: components["schemas"]["HorizontalAlign"];
            verticalAlign: components["schemas"]["VerticalAlign"];
            rotation?: components["schemas"]["AnnotationRotation"];
            /** @description Specifies that the text is supposed to fit in the bounding box. This is only set on new annotations, as we can't easily figure out if an appearance stream contains all the text for existing annotations. */
            isFitting?: boolean;
            /** @description Properties for callout version of text annotation. */
            callout?: {
                start: components["schemas"]["Point"];
                end: components["schemas"]["Point"];
                /** @description Inset applied to the bounding box to size and position the rectangle for the text [left, top, right, bottom]. */
                innerRectInset: number[];
                cap?: components["schemas"]["LineCap"];
                knee?: components["schemas"]["Point"];
            };
            borderStyle?: components["schemas"]["BorderStyle"];
            borderWidth?: number;
            cloudyBorderIntensity?: components["schemas"]["CloudyBorderIntensity"];
            cloudyBorderInset?: components["schemas"]["CloudyBorderInset"];
        };
        /**
         * Intensity
         * @default 0.5
         */
        Intensity: number;
        /** Lines */
        Lines: {
            /** @description Intensities are used to weigh the point during natural drawing. They are received by pressure-sensitive drawing or touch devices. The default value should be used if it's not possible to obtain the intensity. */
            intensities?: components["schemas"]["Intensity"][][];
            /** @description Points are grouped in segments. Points inside a segment are joined to a line. There must be at least one  segment with at least one point. */
            points?: components["schemas"]["Point"][][];
        };
        /**
         * BackgroundColor
         * @description A background color that will fill the bounding box.
         * @example #000000
         */
        BackgroundColor: string;
        /** InkAnnotation */
        InkAnnotation: components["schemas"]["BaseAnnotation"] & {
            /** @enum {string} */
            type: "pspdfkit/ink";
            lines: components["schemas"]["Lines"];
            /** @description The width of the line in PDF points (pt). */
            lineWidth: number;
            /** @description Nutrient's natural drawing mode. This value is only used by Nutrient iOS SDK. */
            isDrawnNaturally?: boolean;
            /** @description True if the annotation should be considered a (soft) ink signature. */
            isSignature?: boolean;
            /**
             * @description The color of the line.
             * @example #ffffff
             */
            strokeColor?: string;
            backgroundColor?: components["schemas"]["BackgroundColor"];
            blendMode?: components["schemas"]["BlendMode"];
            note?: components["schemas"]["AnnotationNote"];
        };
        /** LinkAnnotation */
        LinkAnnotation: components["schemas"]["BaseAnnotation"] & {
            /** @enum {string} */
            type: "pspdfkit/link";
            /**
             * @description A color of the link border.
             * @example #ffffff
             */
            borderColor?: string;
            borderStyle?: components["schemas"]["BorderStyle"];
            borderWidth?: number;
            note?: components["schemas"]["AnnotationNote"];
        };
        /**
         * NoteIcon
         * @enum {string}
         */
        NoteIcon: "comment" | "rightPointer" | "rightArrow" | "check" | "circle" | "cross" | "insert" | "newParagraph" | "note" | "paragraph" | "help" | "star" | "key";
        /** NoteAnnotation */
        NoteAnnotation: components["schemas"]["BaseAnnotation"] & {
            text: components["schemas"]["AnnotationText"];
            icon: components["schemas"]["NoteIcon"];
            /**
             * @description A color that fills the note shape and its icon.
             * @example #ffd83f
             */
            color?: string;
        };
        /** MeasurementScale */
        MeasurementScale: {
            /** @enum {string} */
            unitFrom?: "in" | "mm" | "cm" | "pt";
            /** @enum {string} */
            unitTo?: "in" | "mm" | "cm" | "pt" | "ft" | "m" | "yd" | "km" | "mi";
            from?: number;
            to?: number;
        };
        /**
         * MeasurementPrecision
         * @enum {string}
         */
        MeasurementPrecision: "whole" | "oneDp" | "twoDp" | "threeDp" | "fourDp";
        /**
         * ShapeAnnotation
         * @description Shape annotations are used to draw different shapes on a page.
         */
        ShapeAnnotation: {
            strokeDashArray?: number[];
            strokeWidth?: number;
            /** @example #ffffff */
            strokeColor?: string;
            note?: components["schemas"]["AnnotationNote"];
            measurementScale?: components["schemas"]["MeasurementScale"];
            measurementPrecision?: components["schemas"]["MeasurementPrecision"];
        };
        /**
         * FillColor
         * @example #FF0000
         */
        FillColor: string;
        /** EllipseAnnotation */
        EllipseAnnotation: components["schemas"]["BaseAnnotation"] & components["schemas"]["ShapeAnnotation"] & {
            /** @enum {string} */
            type: "pspdfkit/shape/ellipse";
            fillColor?: components["schemas"]["FillColor"];
            cloudyBorderIntensity?: components["schemas"]["CloudyBorderIntensity"];
            cloudyBorderInset?: components["schemas"]["CloudyBorderInset"];
        };
        /** RectangleAnnotation */
        RectangleAnnotation: components["schemas"]["BaseAnnotation"] & components["schemas"]["ShapeAnnotation"] & {
            /** @enum {string} */
            type: "pspdfkit/shape/rectangle";
            fillColor?: components["schemas"]["FillColor"];
            cloudyBorderIntensity?: components["schemas"]["CloudyBorderIntensity"];
            cloudyBorderInset?: components["schemas"]["CloudyBorderInset"];
        };
        /** LineCaps */
        LineCaps: {
            start?: components["schemas"]["LineCap"];
            end?: components["schemas"]["LineCap"];
        };
        /** LineAnnotation */
        LineAnnotation: components["schemas"]["BaseAnnotation"] & components["schemas"]["ShapeAnnotation"] & {
            /** @enum {string} */
            type: "pspdfkit/shape/line";
            startPoint: components["schemas"]["Point"];
            endPoint: components["schemas"]["Point"];
            fillColor?: components["schemas"]["FillColor"];
            lineCaps?: components["schemas"]["LineCaps"];
        };
        /** PolylineAnnotation */
        PolylineAnnotation: components["schemas"]["BaseAnnotation"] & components["schemas"]["ShapeAnnotation"] & {
            /** @enum {string} */
            type: "pspdfkit/shape/polyline";
            fillColor?: components["schemas"]["FillColor"];
            points: components["schemas"]["Point"][];
            lineCaps?: components["schemas"]["LineCaps"];
            cloudyBorderIntensity?: components["schemas"]["CloudyBorderIntensity"];
            cloudyBorderInset?: components["schemas"]["CloudyBorderInset"];
        };
        /** PolygonAnnotation */
        PolygonAnnotation: components["schemas"]["BaseAnnotation"] & components["schemas"]["ShapeAnnotation"] & {
            /** @enum {string} */
            type: "pspdfkit/shape/polygon";
            fillColor?: components["schemas"]["FillColor"];
            points: components["schemas"]["Point"][];
            cloudyBorderIntensity?: components["schemas"]["CloudyBorderIntensity"];
        };
        /** ImageAnnotation */
        ImageAnnotation: components["schemas"]["BaseAnnotation"] & {
            /** @enum {string} */
            type: "pspdfkit/image";
            /**
             * @description A description of the image.
             * @example PSPDFKit Logo
             */
            description?: string;
            /** @description An optional file name for the image. */
            fileName?: string;
            /**
             * @description MIME type of the image.
             * @enum {string}
             */
            contentType?: "image/jpeg" | "image/png" | "application/pdf";
            /** @description Either the SHA256 Hash of the attachment or the pdfObjectId of the attachment. */
            imageAttachmentId?: string;
            rotation?: components["schemas"]["AnnotationRotation"];
            /** @description True if the annotation should be considered a (soft) signature. */
            isSignature?: boolean;
            note?: components["schemas"]["AnnotationNote"];
        };
        /** StampAnnotation */
        StampAnnotation: components["schemas"]["BaseAnnotation"] & {
            /** @enum {string} */
            type: "pspdfkit/stamp";
            /**
             * @description A type defining the appearance of the stamp annotation. Type 'Custom' displays arbitrary title and subtitle.
             * @enum {string}
             */
            stampType: "Accepted" | "Approved" | "AsIs" | "Completed" | "Confidential" | "Departmental" | "Draft" | "Experimental" | "Expired" | "Final" | "ForComment" | "ForPublicRelease" | "InformationOnly" | "InitialHere" | "NotApproved" | "NotForPublicRelease" | "PreliminaryResults" | "Rejected" | "Revised" | "SignHere" | "Sold" | "TopSecret" | "Void" | "Witness" | "Custom";
            /** @description Custom stamp's title. */
            title?: string;
            /** @description Custom stamp's subtitle. */
            subtitle?: string;
            /**
             * @description Custom stamp's fill color.
             * @example #ffffff
             */
            color?: string;
            rotation?: components["schemas"]["AnnotationRotation"];
            note?: components["schemas"]["AnnotationNote"];
        };
        /**
         * FontSizeAuto
         * @description Size of the text that automatically adjusts to fit the bounding box.
         * @example auto
         * @enum {string}
         */
        FontSizeAuto: "auto";
        /** WidgetAnnotation */
        WidgetAnnotation: components["schemas"]["BaseAnnotation"] & {
            /** @enum {string} */
            type: "pspdfkit/widget";
            /**
             * @description See name property of the FormField schema for more details
             * @example First-Name
             */
            formFieldName?: string;
            /**
             * @description A color of the annotation border.
             * @example #ffffff
             */
            borderColor?: string;
            borderStyle?: components["schemas"]["BorderStyle"];
            borderWidth?: number;
            font?: components["schemas"]["Font"];
            fontSize?: components["schemas"]["FontSizeInt"] | components["schemas"]["FontSizeAuto"];
            fontColor?: components["schemas"]["FontColor"];
            fontStyle?: components["schemas"]["FontStyle"];
            horizontalAlign?: components["schemas"]["HorizontalAlign"];
            verticalAlign?: components["schemas"]["VerticalAlign"];
            rotation?: components["schemas"]["AnnotationRotation"];
            backgroundColor?: components["schemas"]["BackgroundColor"];
        };
        /** CommentMarkerAnnotation */
        CommentMarkerAnnotation: components["schemas"]["BaseAnnotation"] & {
            text?: components["schemas"]["AnnotationText"];
            icon: components["schemas"]["NoteIcon"];
            /**
             * @description A color that fills the note shape and its icon.
             * @example #ffd83f
             */
            color?: string;
            isCommentThreadRoot?: components["schemas"]["IsCommentThreadRoot"];
        };
        /**
         * Annotation JSON v2
         * @description JSON representation of an annotation.
         *
         */
        Annotation: components["schemas"]["MarkupAnnotation"] | components["schemas"]["RedactionAnnotation"] | components["schemas"]["TextAnnotation"] | components["schemas"]["InkAnnotation"] | components["schemas"]["LinkAnnotation"] | components["schemas"]["NoteAnnotation"] | components["schemas"]["EllipseAnnotation"] | components["schemas"]["RectangleAnnotation"] | components["schemas"]["LineAnnotation"] | components["schemas"]["PolylineAnnotation"] | components["schemas"]["PolygonAnnotation"] | components["schemas"]["ImageAnnotation"] | components["schemas"]["StampAnnotation"] | components["schemas"]["WidgetAnnotation"] | components["schemas"]["CommentMarkerAnnotation"];
        /** BaseAnnotation */
        "BaseAnnotation.v1": {
            /**
             * @description The specification version that the record is compliant to.
             * @enum {integer}
             */
            v: 1;
            /** @description The type of the annotation. */
            type: string;
            /** @description Page index of the annotation. 0 is the first page. */
            pageIndex: number;
            bbox: components["schemas"]["AnnotationBbox"];
            action?: components["schemas"]["Action"];
            /** @description Annotation opacity. 0 is fully transparent, 1 is fully opaque. */
            opacity?: number;
            /** @description The PDF object ID of the annotation from the source PDF. */
            pdfObjectId?: number;
            /**
             * @description The unique Instant JSON identifier of the annotation.
             * @example 01DNEDPQQ22W49KDXRFPG4EPEQ
             */
            id?: string;
            /** @description Array of annotation flags.
             *
             *     | Flag | Description |
             *     | ---- | ----------- |
             *     | noPrint | Don't print. |
             *     | noZoom | Don't zoom with page. |
             *     | noRotate | Don't rotate. |
             *     | noView | Don't display, can be still printed. |
             *     | hidden | Don't display, don't print, disable any interaction with user. |
             *     | invisible | Ignore annotation AP stream. |
             *     | readOnly | Don't allow the annotation to be deleted or its properties modified. |
             *     | locked | Same as `readOnly` but allows changing annotation contents. |
             *     | lockedContents | Don't allow the contents of the annotation to be modified. |
             *      */
            flags?: ("noPrint" | "noZoom" | "noRotate" | "noView" | "hidden" | "invisible" | "readOnly" | "locked" | "toggleNoView" | "lockedContents")[];
            /**
             * Format: date-time
             * @description The date of the annotation creation. ISO 8601 with full date, time, and time zone information
             * @example 2019-09-16T15:05:03.712909Z
             */
            createdAt?: string;
            /**
             * Format: date-time
             * @description The date of the last annotation update. ISO 8601 with full date, time, and time zone information
             * @example 2019-09-16T15:05:03.712909Z
             */
            updatedAt?: string;
            /** @description The name of the annotation used to identify the annotation. */
            name?: string;
            /** @description The name of the creator of the annotation. */
            creatorName?: string;
            customData?: components["schemas"]["AnnotationCustomData"];
        };
        /** MarkupAnnotation */
        "MarkupAnnotation.v1": components["schemas"]["BaseAnnotation.v1"] & {
            /** @enum {unknown} */
            type: "pspdfkit/markup/highlight" | "pspdfkit/markup/squiggly" | "pspdfkit/markup/strikeout" | "pspdfkit/markup/underline";
            /** @description Bounding boxes of the marked text. */
            rects: components["schemas"]["Rect"][];
            blendMode?: components["schemas"]["BlendMode"];
            /**
             * @description Foreground color
             * @example #fcee7c
             */
            color: string;
            note?: components["schemas"]["AnnotationNote"];
            isCommentThreadRoot?: components["schemas"]["IsCommentThreadRoot"];
        };
        /** RedactionAnnotation */
        "RedactionAnnotation.v1": components["schemas"]["BaseAnnotation.v1"] & {
            /** @enum {string} */
            type: "pspdfkit/markup/redaction";
            /** @description Bounding boxes of the marked text. */
            rects?: components["schemas"]["Rect"][];
            /**
             * @description Outline color is the border color of a redaction annotation when it hasn't yet been applied to the document
             * @example #ffffff
             */
            outlineColor?: string;
            /** @description Fill color is the background color that a redaction will have when applied to the document. */
            fillColor?: string;
            /**
             * @description The text that will be printed on top of an applied redaction annotation.
             * @example CONFIDENTIAL
             */
            overlayText?: string;
            /** @description Specifies whether or not the overlay text will be repeated multiple times to fill the boundaries of the redaction annotation. */
            repeatOverlayText?: boolean;
            /**
             * @description Color of the overlay text (if any).
             * @example #ffffff
             */
            color?: string;
            rotation?: components["schemas"]["AnnotationRotation"];
            note?: components["schemas"]["AnnotationNote"];
        };
        /**
         * @description The text contents.
         * @example Annotation text.
         */
        AnnotationPlainText: string;
        /** TextAnnotation */
        "TextAnnotation.v1": components["schemas"]["BaseAnnotation.v1"] & {
            /** @enum {string} */
            type: "pspdfkit/text";
            text: components["schemas"]["AnnotationPlainText"];
            fontSize: components["schemas"]["FontSizeInt"];
            /** @description Text style. Can be only italic, only bold, italic and bold, or none of these. */
            fontStyle?: ("bold" | "italic")[];
            fontColor?: components["schemas"]["FontColor"];
            font?: components["schemas"]["Font"];
            /**
             * BackgroundColor
             * @description A background color that will fill the bounding box.
             * @example #000000
             */
            backgroundColor?: string;
            horizontalAlign?: components["schemas"]["HorizontalAlign"];
            verticalAlign?: components["schemas"]["VerticalAlign"];
            rotation?: components["schemas"]["AnnotationRotation"];
            /** @description Specifies that the text is supposed to fit in the bounding box. This is only set on new annotations, as we can't easily figure out if an appearance stream contains all the text for existing annotations. */
            isFitting?: boolean;
            /** @description Properties for callout version of text annotation. */
            callout?: {
                start: components["schemas"]["Point"];
                end: components["schemas"]["Point"];
                /** @description Inset applied to the bounding box to size and position the rectangle for the text [left, top, right, bottom]. */
                innerRectInset: number[];
                cap?: components["schemas"]["LineCap"];
                knee?: components["schemas"]["Point"];
            };
            borderStyle?: components["schemas"]["BorderStyle"];
            borderWidth?: number;
            cloudyBorderIntensity?: components["schemas"]["CloudyBorderIntensity"];
            cloudyBorderInset?: components["schemas"]["CloudyBorderInset"];
        };
        /** InkAnnotation */
        "InkAnnotation.v1": components["schemas"]["BaseAnnotation.v1"] & {
            /** @enum {string} */
            type: "pspdfkit/ink";
            lines: components["schemas"]["Lines"];
            /** @description The width of the line in PDF points (pt). */
            lineWidth: number;
            /** @description Nutrient's natural drawing mode. This value is only used by Nutrient iOS SDK. */
            isDrawnNaturally?: boolean;
            /** @description True if the annotation should be considered a (soft) ink signature. */
            isSignature?: boolean;
            /**
             * @description The color of the line.
             * @example #ffffff
             */
            strokeColor?: string;
            backgroundColor?: components["schemas"]["BackgroundColor"];
            blendMode?: components["schemas"]["BlendMode"];
            note?: components["schemas"]["AnnotationNote"];
        };
        /** LinkAnnotation */
        "LinkAnnotation.v1": components["schemas"]["BaseAnnotation.v1"] & {
            /** @enum {string} */
            type: "pspdfkit/link";
            /**
             * @description A color of the link border.
             * @example #ffffff
             */
            borderColor?: string;
            borderStyle?: components["schemas"]["BorderStyle"];
            borderWidth?: number;
            note?: components["schemas"]["AnnotationNote"];
        };
        /** NoteAnnotation */
        "NoteAnnotation.v1": components["schemas"]["BaseAnnotation.v1"] & {
            text: components["schemas"]["AnnotationPlainText"];
            icon: components["schemas"]["NoteIcon"];
            /**
             * @description A color that fills the note shape and its icon.
             * @example #ffd83f
             */
            color?: string;
        };
        /**
         * ShapeAnnotation
         * @description Shape annotations are used to draw different shapes on a page.
         */
        "ShapeAnnotation.v1": {
            strokeDashArray?: number[];
            strokeWidth?: number;
            /** @example #ffffff */
            strokeColor?: string;
            note?: components["schemas"]["AnnotationNote"];
            measurementScale?: components["schemas"]["MeasurementScale"];
            measurementPrecision?: components["schemas"]["MeasurementPrecision"];
        };
        /** EllipseAnnotation */
        "EllipseAnnotation.v1": components["schemas"]["BaseAnnotation.v1"] & components["schemas"]["ShapeAnnotation.v1"] & {
            /** @enum {string} */
            type: "pspdfkit/shape/ellipse";
            fillColor?: components["schemas"]["FillColor"];
            cloudyBorderIntensity?: components["schemas"]["CloudyBorderIntensity"];
            cloudyBorderInset?: components["schemas"]["CloudyBorderInset"];
        };
        /** RectangleAnnotation */
        "RectangleAnnotation.v1": components["schemas"]["BaseAnnotation.v1"] & components["schemas"]["ShapeAnnotation.v1"] & {
            /** @enum {string} */
            type: "pspdfkit/shape/rectangle";
            fillColor?: components["schemas"]["FillColor"];
            cloudyBorderIntensity?: components["schemas"]["CloudyBorderIntensity"];
            cloudyBorderInset?: components["schemas"]["CloudyBorderInset"];
        };
        /** LineAnnotation */
        "LineAnnotation.v1": components["schemas"]["BaseAnnotation.v1"] & components["schemas"]["ShapeAnnotation.v1"] & {
            /** @enum {string} */
            type: "pspdfkit/shape/line";
            startPoint: components["schemas"]["Point"];
            endPoint: components["schemas"]["Point"];
            fillColor?: components["schemas"]["FillColor"];
            lineCaps?: components["schemas"]["LineCaps"];
        };
        /** PolylineAnnotation */
        "PolylineAnnotation.v1": components["schemas"]["BaseAnnotation.v1"] & components["schemas"]["ShapeAnnotation.v1"] & {
            /** @enum {string} */
            type: "pspdfkit/shape/polyline";
            fillColor?: components["schemas"]["FillColor"];
            points: components["schemas"]["Point"][];
            lineCaps?: components["schemas"]["LineCaps"];
            cloudyBorderIntensity?: components["schemas"]["CloudyBorderIntensity"];
            cloudyBorderInset?: components["schemas"]["CloudyBorderInset"];
        };
        /** PolygonAnnotation */
        "PolygonAnnotation.v1": components["schemas"]["BaseAnnotation.v1"] & components["schemas"]["ShapeAnnotation.v1"] & {
            /** @enum {string} */
            type: "pspdfkit/shape/polygon";
            fillColor?: components["schemas"]["FillColor"];
            points: components["schemas"]["Point"][];
            cloudyBorderIntensity?: components["schemas"]["CloudyBorderIntensity"];
        };
        /** ImageAnnotation */
        "ImageAnnotation.v1": components["schemas"]["BaseAnnotation.v1"] & {
            /** @enum {string} */
            type: "pspdfkit/image";
            /**
             * @description A description of the image.
             * @example PSPDFKit Logo
             */
            description?: string;
            /** @description An optional file name for the image. */
            fileName?: string;
            /**
             * @description MIME type of the image.
             * @enum {string}
             */
            contentType?: "image/jpeg" | "image/png" | "application/pdf";
            /** @description Either the SHA256 Hash of the attachment or the pdfObjectId of the attachment. */
            imageAttachmentId?: string;
            rotation?: components["schemas"]["AnnotationRotation"];
            /** @description True if the annotation should be considered a (soft) signature. */
            isSignature?: boolean;
            note?: components["schemas"]["AnnotationNote"];
        };
        /** StampAnnotation */
        "StampAnnotation.v1": components["schemas"]["BaseAnnotation.v1"] & {
            /** @enum {string} */
            type: "pspdfkit/stamp";
            /**
             * @description A type defining the appearance of the stamp annotation. Type 'Custom' displays arbitrary title and subtitle.
             * @enum {string}
             */
            stampType: "Accepted" | "Approved" | "AsIs" | "Completed" | "Confidential" | "Departmental" | "Draft" | "Experimental" | "Expired" | "Final" | "ForComment" | "ForPublicRelease" | "InformationOnly" | "InitialHere" | "NotApproved" | "NotForPublicRelease" | "PreliminaryResults" | "Rejected" | "Revised" | "SignHere" | "Sold" | "TopSecret" | "Void" | "Witness" | "Custom";
            /** @description Custom stamp's title. */
            title?: string;
            /** @description Custom stamp's subtitle. */
            subtitle?: string;
            /**
             * @description Custom stamp's fill color.
             * @example #ffffff
             */
            color?: string;
            rotation?: components["schemas"]["AnnotationRotation"];
            note?: components["schemas"]["AnnotationNote"];
        };
        /** WidgetAnnotation */
        "WidgetAnnotation.v1": components["schemas"]["BaseAnnotation.v1"] & {
            /** @enum {string} */
            type: "pspdfkit/widget";
            /**
             * @description See name property of the FormFieldContent schema for more details
             * @example First-Name
             */
            formFieldName?: string;
            /**
             * @description A color of the annotation border.
             * @example #ffffff
             */
            borderColor?: string;
            borderStyle?: components["schemas"]["BorderStyle"];
            borderWidth?: number;
            font?: components["schemas"]["Font"];
            fontSize?: components["schemas"]["FontSizeInt"] | components["schemas"]["FontSizeAuto"];
            fontColor?: components["schemas"]["FontColor"];
            horizontalAlign?: components["schemas"]["HorizontalAlign"];
            verticalAlign?: components["schemas"]["VerticalAlign"];
            rotation?: components["schemas"]["AnnotationRotation"];
            backgroundColor?: components["schemas"]["BackgroundColor"];
        };
        /**
         * Annotation JSON v1
         * @description JSON representation of an annotation.
         *
         */
        "Annotation.v1": components["schemas"]["MarkupAnnotation.v1"] | components["schemas"]["RedactionAnnotation.v1"] | components["schemas"]["TextAnnotation.v1"] | components["schemas"]["InkAnnotation.v1"] | components["schemas"]["LinkAnnotation.v1"] | components["schemas"]["NoteAnnotation.v1"] | components["schemas"]["EllipseAnnotation.v1"] | components["schemas"]["RectangleAnnotation.v1"] | components["schemas"]["LineAnnotation.v1"] | components["schemas"]["PolylineAnnotation.v1"] | components["schemas"]["PolygonAnnotation.v1"] | components["schemas"]["ImageAnnotation.v1"] | components["schemas"]["StampAnnotation.v1"] | components["schemas"]["WidgetAnnotation.v1"];
        /**
         * Attachment
         * @description Represents a binary "attachment" associated with an Annotation.
         *
         *     For example, this might be an image attachment for `ImageAnnotation`.
         *
         */
        Attachment: {
            /** @description Base64-encoded binary data of the attachment.
             *      */
            binary?: string;
            /** @description MIME type of the attachment's content. For example, `image/png`.
             *      */
            contentType?: string;
        };
        /**
         * Attachments
         * @description Attachments are defined as an associative array.
         *     * Keys are SHA-256 hashes of the attachment contents or the `pdfObjectId`
         *     of the attachment (in case it's part of the source PDF).
         *     * Values are the actual `Attachment` objects with Base-64 encoded binary
         *     contents of the attachment and its content type.
         *
         * @example {
         *       "388dd55f16b0b7ccdf7abdc7a0daea7872ef521de56ee820b4440e52c87d081b": {
         *         "binary": "YXR0YWNobWVudCBjb250ZW50cwo=",
         *         "contentType": "image/png"
         *       },
         *       "ccbb4499fa6d9f003545fa43ec19511fdb7227ca505bba9f74d787dff57af77b": {
         *         "binary": "YW5vdGhlciBhdHRhY2htZW50IGNvbnRlbnRzCg==",
         *         "contentType": "plain/text"
         *       }
         *     }
         */
        Attachments: {
            [key: string]: components["schemas"]["Attachment"];
        };
        /** BaseFormField */
        BaseFormField: {
            /**
             * @description The specification version that the record is compliant to.
             * @enum {integer}
             */
            v: 1;
            /** @description The type of the form field. */
            type: string;
            /**
             * @description The unique Instant JSON identifier of the form field.
             * @example 7KPSXX1NMNJ2WFDKN7BKQK9KZ
             */
            id?: string;
            /**
             * @description A unique identifier for the form field. This is not visible in the PDF.
             *
             * @example Form-Field
             */
            name: string;
            /**
             * @description The visible name of the form field. It is used to identify the field in the UI for accessibility.
             *
             * @example Form Field
             */
            label: string;
            /**
             * @description The list of Instant JSON identifiers of widget annotations that are associated with this form field.
             *
             *     The widget annotation is used to define the visual appearance of the form field and
             *     to manage user interaction with the form field. Each interactive form control is
             *     associated with separate widget annotation.
             *
             * @example [
             *       "01DNEDPQQ22W49KDXRFPG4EPEQ",
             *       "7KPS6T4DKYN71VB7G5KBGB5R51"
             *     ]
             */
            annotationIds: string[];
            /** @description The PDF object ID of the form field from the source PDF. */
            pdfObjectId?: number;
            /**
             * @description Array of form field flags.
             *
             *     | Flag | Description |
             *     | ---- | ----------- |
             *     | readOnly | Field can't be filled. |
             *     | required | Field needs to have a value when exported by a submit-form action |
             *     | _noExport_ | _(Not supported) Field shall not be exported by a submit-form action. PSPDFKit will read this flag from the PDF and write back changes to its state, but otherwise this flag has no effect._ |
             *
             * @example [
             *       "required"
             *     ]
             */
            flags?: ("readOnly" | "required" | "noExport")[];
        };
        /**
         * ButtonFormField
         * @description A simple push button that responds immediately to user input without retaining any state.
         *
         */
        ButtonFormField: components["schemas"]["BaseFormField"] & {
            /** @enum {string} */
            type: "pspdfkit/form-field/button";
            /** @description Specifies the 'normal' caption of the button */
            buttonLabel: string;
        };
        /** @description A form option identifies a possible option for the form field.
         *      */
        FormFieldOption: {
            /**
             * @description The label of the option.
             * @example One
             */
            label: string;
            /**
             * @description The export value of the option.
             * @example Two
             */
            value: string;
        };
        /**
         * @description The list of form field options.
         *
         *     The index of the widget annotation ID in the `annotationIds`
         *     property corresponds to an index in the  form field option array.
         *
         * @example [
         *       {
         *         "label": "MALE",
         *         "value": "MALE"
         *       },
         *       {
         *         "label": "FEMALE",
         *         "value": "FEMALE"
         *       }
         *     ]
         */
        FormFieldOptions: components["schemas"]["FormFieldOption"][];
        /** @description Default values corresponding to each option.
         *      */
        FormFieldDefaultValues: string[];
        /** @description Additional actions that can be performed on the form field.
         *      */
        FormFieldAdditionalActionsEvent: {
            onChange?: Record<string, never> & components["schemas"]["Action"];
            onCalculate?: Record<string, never> & components["schemas"]["Action"];
        };
        ChoiceFormField: {
            options: components["schemas"]["FormFieldOptions"];
            /**
             * @description If true, more than one of the field's option items may be selected
             *     simultaneously.
             *
             * @default false
             */
            multiSelect: boolean;
            /**
             * @description If true, the new value is committed as soon as a selection is made, without
             *     requiring the user to blur the field.
             *
             * @default false
             */
            commitOnChange: boolean;
            defaultValues?: components["schemas"]["FormFieldDefaultValues"];
            additionalActions?: components["schemas"]["FormFieldAdditionalActionsEvent"];
        };
        /** @description Additional actions that can be performed on the form field.
         *      */
        FormFieldAdditionalActionsInput: {
            onInput?: Record<string, never> & components["schemas"]["Action"];
            onFormat?: Record<string, never> & components["schemas"]["Action"];
        };
        /**
         * ListBoxFormField
         * @description A list box where multiple values can be selected.
         *
         */
        ListBoxFormField: components["schemas"]["BaseFormField"] & components["schemas"]["ChoiceFormField"] & {
            /** @enum {string} */
            type?: "pspdfkit/form-field/listbox";
            additionalActions?: components["schemas"]["FormFieldAdditionalActionsEvent"] & components["schemas"]["FormFieldAdditionalActionsInput"];
        };
        /**
         * ComboBoxFormField
         * @description A combo box is a drop-down box with the option add custom entries (see `edit`).
         *
         */
        ComboBoxFormField: components["schemas"]["BaseFormField"] & components["schemas"]["ChoiceFormField"] & {
            /** @enum {string} */
            type?: "pspdfkit/form-field/combobox";
            /**
             * @description If true, the combo box includes an editable text box as well as a dropdown list. If false, it includes only a drop-down list.
             *
             * @default false
             */
            edit: boolean;
            /**
             * @description If true, the text entered in the field is not spell-checked.
             *
             * @default false
             */
            doNotSpellCheck: boolean;
        };
        /**
         * CheckBoxFormField
         * @description A check box that can either be checked or unchecked. One check box form field can also be associated to multiple single check box widgets
         *
         */
        CheckboxFormField: components["schemas"]["BaseFormField"] & {
            /** @enum {string} */
            type: "pspdfkit/form-field/checkbox";
            options: components["schemas"]["FormFieldOptions"];
            defaultValues: components["schemas"]["FormFieldDefaultValues"];
            additionalActions?: components["schemas"]["FormFieldAdditionalActionsEvent"];
        };
        /** @description Default value of the form field.
         *      */
        FormFieldDefaultValue: string;
        /**
         * RadioButtonFormField
         * @description A group of radio buttons. Similar to `CheckBoxFormField`, but there can only be one value set at the same time.
         *
         */
        RadioButtonFormField: components["schemas"]["BaseFormField"] & {
            /** @enum {string} */
            type: "pspdfkit/form-field/radio";
            options: components["schemas"]["FormFieldOptions"];
            defaultValue?: components["schemas"]["FormFieldDefaultValue"];
            /**
             * @description If true, exactly one radio button must be selected at all times.
             *     Clicking the currently selected button has no effect. Otherwise,
             *     clicking the selected button deselects it, leaving no button selected.
             *
             * @default false
             */
            noToggleToOff: boolean;
            /**
             * @description If true, a group of radio buttons within a radio button field that use
             *     the same value for the on state will turn on and off in unions: If one is
             *     checked, they are all checked (the same behavior as HTML radio buttons).
             *     Otherwise, only the checked radio button will be marked checked.
             *
             * @default false
             */
            radiosInUnison: boolean;
        };
        /**
         * TextFormField
         * @description A text input element, that can either span a single or multiple lines.
         *
         */
        TextFormField: components["schemas"]["BaseFormField"] & {
            /** @enum {string} */
            type: "pspdfkit/form-field/text";
            /**
             * @description If true, the field is intended for entering a secure password that should not be echoed visibly
             *      to the screen. Characters typed from the keyboard should instead be echoed in some unreadable
             *      form, such as asterisks or bullet characters.
             *
             * @default false
             */
            password: boolean;
            /** @description The maximum length of the field's text, in characters. If none is set, the size is not limited.
             *      */
            maxLength?: number;
            /**
             * @description If true, the text entered in the field is not spell-checked.
             *
             * @default false
             */
            doNotSpellCheck: boolean;
            /**
             * @description If true, the field does not scroll (horizontally for single-line fields, vertically for multiple-line fields)
             *     to accommodate more text than fits within its widget annotation's rectangle. Once the field is full, no further
             *     text is accepted.
             *
             * @default false
             */
            doNotScroll: boolean;
            /**
             * @description If true, the field can contain multiple lines of text. Otherwise, the field's text is restricted to a single line.
             *
             * @default false
             */
            multiLine: boolean;
            /**
             * @description If true, every character will have an input element on their own which is evenly distributed inside
             *     the bounding box of the widget annotation. When this is set, the form field must have a `maxLength``.
             *
             * @default false
             */
            comb: boolean;
            defaultValue: components["schemas"]["FormFieldDefaultValue"];
            /**
             * @description _(Not Supported) Rich text rendering is not supported right now. Any rich text value will be displayed as plain text in case the regular text value is missing._
             *
             * @default false
             */
            richText: boolean;
            /** @description _(Not Supported) Rich text rendering is not supported right now. Any rich text value will be displayed as plain text in case the regular text value is missing._
             *      */
            richTextValue?: string;
            additionalActions?: components["schemas"]["FormFieldAdditionalActionsEvent"] & components["schemas"]["FormFieldAdditionalActionsInput"];
        };
        /**
         * SignatureFormField
         * @description A field that contains a digital signature.
         *
         */
        SignatureFormField: components["schemas"]["BaseFormField"] & {
            /** @enum {string} */
            type?: "pspdfkit/form-field/signature";
        };
        /**
         * Form field JSON
         * @description JSON representation of a form field
         *
         */
        FormField: components["schemas"]["ButtonFormField"] | components["schemas"]["ListBoxFormField"] | components["schemas"]["ComboBoxFormField"] | components["schemas"]["CheckboxFormField"] | components["schemas"]["RadioButtonFormField"] | components["schemas"]["TextFormField"] | components["schemas"]["SignatureFormField"];
        /**
         * FormFieldValue
         * @description A record representing a form field value.
         *
         *     ## Choice Fields
         *
         *     When creating form fields with multiple widgets like `CheckBoxFormField` or `RadioButtonFormField`, you need to ensure two things:
         *     - The number of annotations in the `annotationIds` field must be equal to the number of elements in the `options` field.
         *     - For each option in `options` you need to specify the `annotationId` that is mapped to this specific option on the PDF.
         *
         *     The list of `options` in a `CheckBoxFormField` or `RadioButtonFormField` are the names of the `ON` state appearance
         *     of each widget annotation that is a child of the form field. The `options` array and the `annotationWidgetIds`
         *     array keep the same order, that is, the `ON` state appearance name for `annotationIds[0]` is in `options[0]`.
         *     The value of the `OFF` state is customizable but always has the same name, "Off", so it's not included in the model.
         *
         *     In order to check a checkbox or radio button, if the `options` list contains, for example, `["Checked"]`,
         *     then you need to and pass the same list. The system will internally notice that you are setting the form
         *     value of a checkbox or radio button and automatically interpret "Checked" not as text, but as the PDF name
         *     that represents an appearance stream named "Checked", representing the ON state.
         *
         *     The same applies to the OFF state, which by design always has the name "Off", as explained previously.
         *
         */
        FormFieldValue: {
            /** @description Unique name of the form field. This property is used to link form field value to a `FormField`.
             *      */
            name: string;
            value?: (string | null) | string[];
            /** @enum {string} */
            type: "pspdfkit/form-field-value";
            /**
             * @description The specification version that the record is compliant to.
             * @enum {integer}
             */
            v: 1;
            /** @description Radio buttons and checkboxes can have multiple widgets with the same form value associated,
             *     but can be selected independently. `optionIndexes`` contains the value indexes that should be actually set.
             *
             *     If set, the value field doesn't get used, and the widget found at the corresponding indexes in
             *     the form field's annotationIds property are checked.
             *
             *     If set on fields other than `RadioButtonFormField` or `CheckBoxFormField`, setting the form value will fail.
             *      */
            optionIndexes?: number[];
            /**
             * @description Specifies if the given text should fit into the visible portion of the text form field.
             *
             * @default false
             */
            isFitting: boolean;
        };
        /**
         * Bookmark
         * @description A record representing a bookmark.
         *
         */
        Bookmark: {
            /** @description The optional bookmark name. This is used to identify the bookmark.
             *      */
            name?: string;
            /** @enum {string} */
            type: "pspdfkit/bookmark";
            /**
             * @description The specification version that the record is compliant to.
             * @enum {integer}
             */
            v: 1;
            action: components["schemas"]["Action"];
            /** @description The PDF object ID of the bookmark in the PDF.
             *      */
            pdfBookmarkId?: string;
        };
        /**
         * IsoDateTime
         * @description Date and time in ISO8601 format with timezone.
         * @example 2019-09-16T15:05:03.712909Z
         */
        IsoDateTime: string;
        /**
         * CustomData
         * @description Object of arbitrary properties attached to an entity
         */
        CustomData: {
            [key: string]: unknown;
        } | null;
        /** Comment JSON v2 */
        "InstantComment.v2": {
            /** @enum {string} */
            type: "pspdfkit/comment";
            pageIndex: components["schemas"]["PageIndex"];
            /**
             * @description The ID of the root annotation of the comment thread.
             *
             * @example 01HBDGR9D5JTFERPSCEMNH5GPG
             */
            rootId: string;
            text: components["schemas"]["AnnotationText"];
            /**
             * @description The instant JSON specification version that the record is compliant to.
             *
             * @enum {integer}
             */
            v: 2;
            createdAt?: components["schemas"]["IsoDateTime"];
            /**
             * @description The name of the user who created the comment.
             *
             * @example John Doe
             */
            creatorName?: string;
            customData?: components["schemas"]["CustomData"];
            pdfObjectId?: components["schemas"]["PdfObjectId"];
            updatedAt?: components["schemas"]["IsoDateTime"];
        };
        /** Comment JSON v1 */
        "InstantComment.v1": {
            /** @enum {string} */
            type: "pspdfkit/comment";
            pageIndex: components["schemas"]["PageIndex"];
            /**
             * @description The ID of the root annotation of the comment thread.
             *
             * @example 01HBDGR9D5JTFERPSCEMNH5GPG
             */
            rootId: string;
            /**
             * @description The text of the comment
             * @example A comment is made of words
             */
            text: string;
            /**
             * @description The instant JSON specification version that the record is compliant to.
             *
             * @enum {integer}
             */
            v: 1;
            createdAt?: components["schemas"]["IsoDateTime"];
            /**
             * @description The name of the user who created the comment.
             *
             * @example John Doe
             */
            creatorName?: string;
            customData?: components["schemas"]["CustomData"];
            pdfObjectId?: components["schemas"]["PdfObjectId"];
            updatedAt?: components["schemas"]["IsoDateTime"];
        };
        /**
         * Comments JSON
         * @description JSON representation of a comment.
         *
         */
        CommentContent: components["schemas"]["InstantComment.v2"] | components["schemas"]["InstantComment.v1"];
    };
    responses: {
        /** @description The processing result. One of the following:
         *     * PDF file for `pdf` and `pdfa` output types.
         *     * Image file for `image` output types.
         *     * JSON with document contents for `json-content` output type.
         *     * Office file for `docx`, `xlsx`, and `pptx` output types.
         *      */
        BuildResponseOk: {
            headers: {
                "x-pspdfkit-request-cost": components["headers"]["x-pspdfkit-request-cost"];
                "x-pspdfkit-remaining-credits": components["headers"]["x-pspdfkit-remaining-credits"];
                [name: string]: unknown;
            };
            content: {
                "application/pdf": string;
                "application/json": components["schemas"]["JSONContentOutput"];
                "application/jpeg": string;
                "application/png": string;
                "application/webp": string;
                "application/zip": string;
                "application/vnd.openxmlformats-officedocument.wordprocessingml.document": string;
                "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": string;
                "application/vnd.openxmlformats-officedocument.presentationml.presentation": string;
            };
        };
    };
    parameters: {
        /** @description The PDF document password.
         *
         *     The value can be either either a plain-text password or a base64 encoded password in a form `base64:<encoded-password>`.
         *     Use the Base64 encoding if your password contains characters that are not allowed in HTTP header or would be otherwise mangled
         *     (e.g. trailing or leading spaces)
         *
         *     If the document is password protected, any operations performed on it require supplying a password.
         *      */
        Password: string;
    };
    requestBodies: never;
    headers: {
        /** @description Cost of the request in credits.
         *      */
        "x-pspdfkit-request-cost": number;
        /** @description Remaining credits after the request has been executed. Note that this
         *     value is only informational, as it doesn't include pending credit
         *     deductions on your account.
         *      */
        "x-pspdfkit-remaining-credits": number;
    };
    pathItems: never;
}
export type $defs = Record<string, never>;
export interface operations {
    "build-document": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["BuildInstructions"];
                "multipart/form-data": {
                    instructions?: components["schemas"]["BuildInstructions"];
                };
            };
        };
        responses: {
            200: components["responses"]["BuildResponseOk"];
            /** @description The request is malformed. Some invalid data was supplied, or a precondition wasn't met.
             *      */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HostedErrorResponse"];
                };
            };
            /** @description You are unauthorized. Sent when no API token is specified, or when the API token you specified isn't valid.
             *      */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description You have exceeded the total number of documents processed in your subscription.
             *      */
            402: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description The request timed out.
             *      */
            408: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description The request exceeds the maximum input size, meaning either a single part, or the sum of all parts, is large.
             *      */
            413: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description The request exceeds the maximum output file size.
             *      */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description An internal server error occurred. Please contact support.
             *      */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    analyze_build: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["BuildInstructions"];
            };
        };
        responses: {
            /** @description The analysis result. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AnalyzeBuildResponse"];
                };
            };
            /** @description The request is malformed. Some invalid data was supplied, or a precondition wasn't met.
             *      */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HostedErrorResponse"];
                };
            };
            /** @description You are unauthorized. Sent when no API token is specified, or when the API token you specified isn't valid.
             *      */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description The request timed out.
             *      */
            408: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description An internal server error occurred. Please contact support.
             *      */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "sign-file": {
        parameters: {
            query?: never;
            header?: {
                /** @description The PDF document password.
                 *
                 *     The value can be either either a plain-text password or a base64 encoded password in a form `base64:<encoded-password>`.
                 *     Use the Base64 encoding if your password contains characters that are not allowed in HTTP header or would be otherwise mangled
                 *     (e.g. trailing or leading spaces)
                 *
                 *     If the document is password protected, any operations performed on it require supplying a password.
                 *      */
                "pspdfkit-pdf-password"?: components["parameters"]["Password"];
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: {
            content: {
                "multipart/form-data": {
                    /**
                     * Format: binary
                     * @description The binary content of a PDF file to be signed.
                     * @example <PDF data>
                     */
                    file: string;
                    /** @description Optional signing parameters. If omitted, defaults will be used:
                     *     - `signatureType`: `cms`
                     *     - `flatten`: `false`
                     *     - An invisible signature will be created
                     *      */
                    data?: components["schemas"]["CreateDigitalSignature"];
                    /**
                     * Format: binary
                     * @description The watermark image to be used as part of the signature's appearance. Optional.
                     * @example <Image data>
                     */
                    image?: string;
                    /**
                     * Format: binary
                     * @description The graphic image to be used as part of the signature's appearance. Optional.
                     * @example <Image data>
                     */
                    graphicImage?: string;
                };
            };
        };
        responses: {
            /** @description The signed document. */
            200: {
                headers: {
                    "x-pspdfkit-request-cost": components["headers"]["x-pspdfkit-request-cost"];
                    "x-pspdfkit-remaining-credits": components["headers"]["x-pspdfkit-remaining-credits"];
                    [name: string]: unknown;
                };
                content: {
                    "application/pdf": string;
                };
            };
            /** @description The request is malformed. Some invalid data was supplied, or a precondition wasn't met.
             *      */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HostedErrorResponse"];
                };
            };
            /** @description You are unauthorized. Sent when no API token is specified, or when the API token you specified isn't valid.
             *      */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description You have exceeded the total number of documents processed in your subscription.
             *      */
            402: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description The request timed out.
             *      */
            408: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description The request exceeds the maximum input size, meaning either a single part, or the sum of all parts, is large.
             *      */
            413: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description The request exceeds the maximum output file size.
             *      */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description An internal server error occurred. Please contact support.
             *      */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "generate-token": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["CreateAuthTokenParameters"];
            };
        };
        responses: {
            /** @description The generated API token. */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CreateAuthTokenResponse"];
                };
            };
            /** @description The request is malformed. Some invalid data was supplied, or a precondition wasn't met.
             *      */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @example 400 */
                        status?: number;
                        errors?: {
                            /** @example Description of error */
                            allowedOperations?: string;
                            /** @example Description of error */
                            allowedOrigins?: string;
                            /** @example Description of error */
                            expirationTime?: string;
                        }[];
                    };
                };
            };
        };
    };
    "revoke-token": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": {
                    /**
                     * @description The ID of the token to revoke.
                     * @example FCKGW-RHQQ2-YXRKT-8TG6W-2B7Q8
                     */
                    id?: string;
                };
            };
        };
        responses: {
            /** @description The token was successfully revoked. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description The token was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "get-account-info": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Account information. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @description Information about your API keys. */
                        apiKeys?: {
                            /** @description Your live API key. */
                            live?: string;
                        };
                        /**
                         * @description Whether you are signed in.
                         * @example true
                         */
                        signedIn?: boolean;
                        /**
                         * @description Your subscription type.
                         * @enum {unknown}
                         */
                        subscriptionType?: "free" | "paid" | "enterprise";
                        /** @description Information about your usage. */
                        usage?: {
                            /**
                             * @description The number of credits available in the current billing period.
                             * @example 100
                             */
                            totalCredits?: number;
                            /**
                             * @description The number of credits you have used in the current billing period.
                             * @example 50
                             */
                            usedCredits?: number;
                        };
                    };
                };
            };
            /** @description You are unauthorized. Sent when no API token is specified, or when the API token you specified isn't valid.
             *      */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "ai-redact": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: {
            content: {
                "multipart/form-data": {
                    /** @description Parameters required for the redaction.
                     *      */
                    data: components["schemas"]["RedactData"];
                    /**
                     * Format: binary
                     * @description The PDF file to process.
                     * @example <PDF data>
                     */
                    file: string;
                };
                "application/json": components["schemas"]["RedactData"];
            };
        };
        responses: {
            /** @description The redacted document */
            200: {
                headers: {
                    "x-pspdfkit-request-cost"?: number;
                    "x-pspdfkit-remaining-credits"?: number;
                    [name: string]: unknown;
                };
                content: {
                    "application/pdf": string;
                };
            };
            /** @description The request is malformed. Some invalid data was supplied, or a precondition wasn't met.
             *      */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @example 400 */
                        status?: number;
                        errors?: Record<string, never>[];
                    };
                };
            };
            /** @description You are unauthorized. Sent when no API token is specified, or when the API token you specified isn't valid.
             *      */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description You have exceeded the total number of documents processed in your subscription.
             *      */
            402: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description The request timed out.
             *      */
            408: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description The request exceeds the maximum input size, meaning either a single part, or the sum of all parts, is large.
             *      */
            413: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description The request exceeds the maximum output file size.
             *      */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description An internal server error occurred. Please contact support.
             *      */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
}
